<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="preconnect" href="https://giscus.app" crossorigin>
  <link rel="preload" as="style" href='/scss/clean-blog-min.css'/>

    <meta name="description" content="Security through Certificates (01:28:31)">

  <title>Module 4 - Security through Certificates</title>


  <link rel="canonical" href='https://blog.allengaodev.com/backlogs/Practical-TLS/module4-security-through-certificates'>

      <link type="application/rss+xml" rel="alternate" title="&#x958B;&#x767C;&#x7A7A;&#x9593;" href="/feed.rss" />
      <link type="application/atom+xml" rel="alternate" title="&#x958B;&#x767C;&#x7A7A;&#x9593;" href="/feed.atom" />

  <meta name="application-name" content='Gao.Dev' />
  <meta name="msapplication-tooltip" content='Gao.Dev' />
  <meta name="msapplication-starturl" content='/' />
  <meta name="google-site-verification" content="aq71qXzppLuXZ8be8mjOwn_zJq317ZSD34yTS4i6y6M" />
  <meta property="og:title" content='Module 4 - Security through Certificates' />
    <meta property="og:image" content='/assets/img/101night.avif' />
  <meta property="og:type" content="website" />
  <meta property="og:url" content='https://blog.allengaodev.com/backlogs/Practical-TLS/module4-security-through-certificates' />

  <link rel="icon" href='/favicon.svg'>

  <!-- Styles for this template (also includes Bootstrap) -->
  <link href='/scss/clean-blog-min.css' rel="stylesheet">
  <script async src='/vendor/quicklink/js/quicklink.umd.js' onload="quicklink.listen();"></script>
  <script async src='/vendor/prismjs/js/prism-core.min.js'></script>
  <script async src='/vendor/prismjs/js/prism-autoloader.min.js'></script>
  <link href='/vendor/prismjs/css/prism.min.css' rel="stylesheet" media="print" onload="this.media='all'">

  <!-- Google tag (gtag.js)-->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-EBB8LGKD99"></script>
  <script> function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-EBB8LGKD99"); </script>

  


  

</head>

<body>

  <!-- Navigation -->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href='/'> Home </a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-bs-toggle="collapse" data-bs-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
      Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ms-auto">
          <!-- <li class="nav-item">
            <span class="nav-link">
              <form class="form-inline my-2 my-lg-0" action="/search" method="GET">
                <input class="form-control mr-sm-2" type="search" placeholder="Search" aria-label="Search" name="query" id="search-query-nav">
                <input type="submit" hidden />
              </form>
            </span>
          </li> -->
          <li class="nav-item">
    <a class="nav-link" href="/search">Search</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="/posts">Posts</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="/tags">Tags</a>
  </li>

      </ul>
    </div>
  </div>
</nav>


  <!-- Page Header -->
  <header class="masthead" style="background-image: url(&quot;/assets/img/101night.avif&quot;)">
  <div class="container position-relative">
    <div class="row">
      <div class="col-md-12">
        <div class='site-heading'>
          <h1>
            <a style="color:white" href='https://blog.allengaodev.com/backlogs/Practical-TLS/module4-security-through-certificates'>Module 4 - Security through Certificates</a>
          </h1>
        </div>
      </div>
    </div>
  </div>
</header>


  <!-- Main Content -->
  <div class="container">
    <div class="row">
      <div id="content" class="col-md-12">
        <h2 id="overview-of-the-ssl-process-part-2-0440">4.1 Overview of the SSL Process, part 2 (04:40)</h2>
<ol>
<li>CA 自己產生 Public Key/Private Key/Self Signed Certificate</li>
<li>Server 想要申請 Certificate</li>
<li>Server 自己產生 Public Key/Private Key</li>
<li>Server 產生 CSR，內容是 Public key 之後使用 Private Key 簽名</li>
<li>Server 將這份 CSR 交給 CA</li>
<li>CA 檢查 CSR 內容</li>
<li>CA 根據 CSR 內容產生 Certificate</li>
<li>CA 使用自己的 Private Key 簽屬這份 Certificate</li>
<li>CA 將 Certificate 交還給 Server</li>
<li>Server 可以將 Certificate 提供給 Client 來證明自己的身分</li>
<li>Client 想要連線到 Server，Client 的瀏覽器安裝的時候就已經內建許多 CA 的 Certificate，接下來就不需要 CA 了</li>
<li>Client 請求 Server 的 Certificate，收到後因為 Server 的 Certificate 簽名是用 CA 的 Private Key 簽屬的，這時候就可以使用
Client 手上有的 CA 的 Certificate，裡面擁有 CA 的 Public 資訊，所以 Client 就可以知道這份 Server 證書是不是合法的，因為
證書是公開的，大家都可以下載，所以要確認是否是真的 Server 提供的，還是從仿冒的 Server 提供的</li>
<li>這個確認的過程就是 SSL/TLS HandShake，Client 要提交 Certificate，如果 Server 真的有對應的 Private Key 那就能正確建立連線</li>
<li>SSL/TLS HandShake 成功後會產生 Session Key，包含 Symmetric Key 與 MAC</li>
<li>有了 Session Key 加密資料就能保護 Server 與 Client 資料傳遞的安全。</li>
</ol>
<h2 id="certificate-validation-part-1-0534">4.2 Certificate Validation - Part 1 (05:34)</h2>
<p>當 Client 接收到 Certificate 的時候需要驗證兩點:</p>
<ol>
<li>檢查 Certificate 是否具有效力，因為它本質上就是一串文字，所以接收到的內容很容易被修改。</li>
<li>確認 Server 是否真的擁有這份 Certificate，因為它是公開的，任何人都可以下載並分享。</li>
</ol>
<p>我們知道 Certificate 是有三個區塊 Certificate Data、Signature Algorithm、Signature 所組成，首先 CA 需要透過 Certificate Data
產生 Hashing，之後 CA 在使用自己的 Private Key 與 Hashing 計算之後產生 Signature，之後再把證書交還給 Server。</p>
<p>當 Client 收到 Certificate 的時候因為瀏覽器已經內建 CA 的證書，就能直接用 CA Public Key 把 Certificate 的 Signature 區段資料
解密得出 Hash 值，同時 Client 又同時對 Certificate Data 做 Hashing，這兩邊的結果一致就代表資料沒有被修改過。</p>
<p>DSA 的流程差不多只是少了 Client 對 Certificate Data 做 Hashing 這一段步驟，因為 DSA 可以直接用簽名驗證的方式，只要直接用 CA Public Key
就能透過回傳值 0 或 1 知道證書是否具備合法效力。</p>
<h2 id="certificate-validation-part-2-0950">4.3 Certificate Validation - Part 2 (09:50)</h2>
<p>確認 Server 是否真的擁有這份 Certificate，因為它是公開的，任何人都可以下載並分享。</p>
<p>因為有可能一台假 Server 先跟真的 Server 建立連線並回傳 Certificate 給假 Server，之後假 Server 再偽裝自己是真 Server 並提供 Certificate。
首先第一個驗證合法效力的步驟會通過，因為確實是拿真的 Certificate 來驗證。</p>
<p>所以第二個驗證更加重要，必須要確認給妳這個 Certificate 的 Server 是真的 Server，
要驗證這個問題需要透過 Server 的 Private Key，因為只有真的 Server 才擁有與 Certificate 搭配的 Private Key。</p>
<p>有兩個驗證方法:</p>
<ol>
<li><code>Client Initiated</code>
由 Client 隨機產生一個值，並且使用 Certificate 裡面的 Public Key 對這個值進行加密，這樣全世界就只有與這個 Certificate 搭配的 Private Key
才能解開，這樣 Client 與 Server 都擁有一個相同的隨機值，但要想辦法讓 Client 知道 Server 已經解密成功。</li>
</ol>
<p>所以實際上這個隨機值是用來建立 Session Key，也就是 Client 使用這個隨機值產生 Session Key，並且用 Certificate 裡面的 Public Key 對這個值進行加密，
當 Server 解密成功的時候也會得到同樣的隨機值，這樣 Server 也能夠建立一組 Session Key，這樣 Server 與 Client 都有同樣的 Session Key 了。</p>
<p>這時候並不需要讓 Client 知道 Server 已經解密成功，Client 下次只需要直接發送用 Session Key 加密過後的資料就好，
因為 Server 能解密這份資料就能間接知道 Server 已經解密成功，這樣兩邊就能正常溝通了。</p>
<ol start="2">
<li><code>Server Initiated</code>
由 Server 開始建立請求，那就是 Server 負責產生隨機產生值同樣也是生成 Session Key ，並且 Server 用自己的 Private Key 對隨機值進行簽名，之後 Client
就能用 Public Key 進行驗證並建立相同的 Session Key，成功的話就代表 Server 是真的這份 Certificate 的擁有者，兩邊開始溝通。</li>
</ol>
<p>但是 Server 這裡回傳的只是經過簽名的隨機值，所以可能被中間的人竊聽，那就有機率與不正確的 Client 建立連線，所以這個隨機值還不夠還需要另外的機制確保機密性，
因此產生 Session Key 時還需要一些只有正確 Client 才知道的值才能確保與正確的 Client 進行連線。</p>
<p>這兩個驗證方式就是在進行 Authentication 與 Key Exchange 兩個動作。
所以要挑選正確的演算法，例如第一個 <code>Client Initiated</code> 的方式因為有加解密的動作，所以 Authentication 適合用 RSA， Key Exchange 則是適合 RSA，因為這個過程有加解密所以直接用 RSA。
第二個 <code>Server Initiated</code> 的方式則是需要透過簽名，所以 Authentication 適合用 RSA 或 DSA， Key Exchange 則是適合 DH，因為這個過程沒有加解密所以不能用 RSA。</p>
<h2 id="certificate-chains-part-1-1024">4.4 Certificate Chains - Part 1 (10:24)</h2>
<p>瀏覽器內建 CA Certificate 是不太安全並且也很難更新，例如某個 CA Certificate 已經被盜用，那麼我們的瀏覽器沒有即時更新就有可能跟
錯誤的 Server 建立連線，並且有很多電腦是不跑更新的。</p>
<p>所以 CA 將權力細分化，最上層的叫做 Root CA，它將權力分散給多個 Intermediate CAs，之後讓簽發憑證的工作交給 Intermediate CAs，
這樣確保 Root CA 不要去做一般的簽發憑證，就能降低 Root CA 出事的機率，並且就算出事也只有 Intermediate CAs 會出事，這樣只要把
那個有問題節點的 CA 憑證撤銷掉就能避免問題擴散，也同時能確保我們瀏覽器裡內建的 Root CA 不用頻繁更新。</p>
<p>Root CA 的 Private Key 要盡量避免使用，要有使用越多次就越可能出事的認知，所以這個 Private Key 通常存放在沒有網路的地點，
通常叫做 「air gapped」 系統或者 HSMs，更安全的做法就是把 Private Key 在拆分成小塊，分散儲存到多個地點。</p>
<p>Intermediate CAs 可以在依照功能或地區建立出更多 Intermediate CAs，總之最後就會產生一條 <code>Chain</code> 並回到源頭的 Root CA。</p>
<ol>
<li>源頭就是 Root CA 產生 Public Key/Private Key/Self Signed Certificate</li>
<li>第一層的 ICA 產生 Public Key/Private Key 接下來產生 CSR 傳送給 Root CA 簽名取得 Certificate</li>
<li>第二層的 ICA 產生 Public Key/Private Key 接下來產生 CSR 傳送給 第一層的 ICA 簽名取得 Certificate</li>
<li>第三層的 ICA 產生 Public Key/Private Key 接下來產生 CSR 傳送給 第二層的 ICA 簽名取得 Certificate
....</li>
</ol>
<p>一條 <code>Chain</code> 最底部就是我們在使用的 Server Certificate，產生的 <code>Chain</code> 是根據每個 Certificate 都有的 Subject 與 Issuer
一層一層串聯起來的。</p>
<p>I: Orange Root CA
S: Orange Root CA</p>
<p>I: Orange Root CA
S: Purple ICA</p>
<p>I: Purple ICA
S: Red ICA</p>
<p>I: Red ICA
S: blue.com</p>
<h2 id="certificate-chains-part-2-0435">4.5 Certificate Chains - Part 2 (04:35)</h2>
<p>一條 Chain 有這麼多的憑證，那麼該給 Client 端什麼憑證才是對的。</p>
<ol>
<li>首先 Root CA Certificate 已經預先安裝在瀏覽器內了</li>
<li>連線到 blue.com 那這個 Server 就必須把它的 Server Certificate 傳送給 Client</li>
<li>但是目前 Server Certificate 的簽屬人是 Red ICA，Client 並不認識 Red ICA 是誰，所以沒辦法相信 Server Certificate</li>
<li>所以 Server 必須同時把所有 Intermediate CAs 都傳送給 Client，才能一層一層驗證</li>
<li>每一層 ICA 都認證過後才會輪到 Server Certificate 驗證，最後 Client 才會相信</li>
</ol>
<p>Server 也可以選擇把 Root CA Certificate 也丟給 Client，但是 Client 會選擇相信預先安裝的 Root CA Certificate，
而不是 Server 傳送過來的。</p>
<p>Server 選擇傳送 Root CA Certificate 是因為有些內部的網站，並不是使用公開的 Root CA，而是用公司內部的 Root CA，
所以一起傳送可以方便 Client 直接訪問公司內部網站。</p>
<h2 id="basic-constraints-0738">4.6 Basic Constraints (07:38)</h2>
<p>由於任何人都能產生一組 Public Key/Private Key，並且產生 CSR 只要一組域名與 Public Key/Private Key，代表你可以直接
使用別人的域名來產生 CSR。</p>
<p>如果你直接拿這份 CSR 到 CA 就會被擋下，因為你不是這個域名的擁有者。</p>
<p>但是如果你是交給 blue.com 的 Server 擁有的 Certificate 進行簽屬這個盜用的 CSR，那麼就會產生一個盜用的 Certificate，
這樣這個 Certificate 就會被加入到整條 Chain 中，也就會被 Client 相信。</p>
<p>所以 Chain 的缺陷就是任何人都能使用合法的 Certificate 來簽屬另一個 Certificate 不管它正不正當。</p>
<p>Basic Constraints 是在 1999 才正式通過，所以以前的網站很可能不能保證連線到的 Server 是真的 Server。</p>
<p>Basic Constraints 有兩個參數:</p>
<ol>
<li>CA: TRUE/FALSE (用來確認這個 Certificate 的 Subject 是不是 CA)</li>
<li>PATH LENGTH: 一個 Chain 中最多能存在幾的 ICA</li>
</ol>
<p>加上 PATH LENGTH 可以增加安全性，如果最後一層的 ICA 忘記添加 <code>CA: False</code>，也能避免它亂發 Certificate</p>
<p>CA: TRUE, path len: 2
CA: TRUE, path len: 1
CA: TRUE, path len: 0
CA: False, path len: 0</p>
<h2 id="certificate-types-dv-ov-ev-1125">4.7 Certificate Types (DV, OV, EV) (11:25)</h2>
<p>要申請一個 SSL/TLS 憑證，首先需要產生 CSR 並提交給 CA 審核，CA 審核身分有三種方式:</p>
<ol>
<li>DV: Domain Validation</li>
<li>OV: Organization Validation</li>
<li>EV: Extended Validation</li>
</ol>
<h3 id="dv-domain-validation">DV: Domain Validation</h3>
<p>根據 Domain 的形式來驗證你是否真的是這個域名的擁有者。</p>
<ul>
<li><p>例如透過 Email 的方式來進行確認，這邊的 <code>domain.com</code> 代表你買的域名，所以你能收到信代表你是真的域名擁有者。
info&#64;domain.com, ssl&#64;domain.com, admin&#64;domain.com, etc...</p>
</li>
<li><p>或是透過透過 URL 提供 token 來進行驗證，需要建立額外的頁面並且內部要包含特定的 Token，這樣 CA 一訪問這個頁面就能知你是真的域名擁有者。
<code>http://domain.com/token.html</code></p>
</li>
</ul>
<p>使用 <code>https://letsencrypt.org</code> 來產生免費的憑證。</p>
<h3 id="ov-organization-validation">OV: Organization Validation</h3>
<p>就是 DV 模式的進階版，要求 CA 需要驗證域名的公司資訊，確保它是存在的公司，這種驗證需要花費比較多的時間。</p>
<h3 id="ev-extended-validation">EV: Extended Validation</h3>
<p>就是 OV 模式的進階版，要求 CA 要實際確認公司的設立地址，並透過寄信或訪問的方式確認，並且公司要運作超過三年，
確認 CSR 申請人是真的在公司內並且有權力申請的，還要確認 CA 跟 公司之間的通訊是穩定可靠的。</p>
<p>要花最多錢並且要 7~14 天審核。</p>
<p>但是有 EV 審核通過的網站會有特殊的標示，並不是像 DV 與 OV 只有一般的小綠鎖，但是現在已經統一標示了。</p>
<h3 id="security">Security</h3>
<p>並不代越貴的越安全，因為關鍵是驗證身分並不是這個身分的申請難度，例如護照就比身分證難申請，但不管是看到護照還是身分證都能確定你的真實身分，
所以就算護照再難申請，對於驗證身分的角度來看跟身分證的安全性是一樣的。</p>
<h3 id="certificate-type">Certificate Type</h3>
<p>決定使用哪種驗證方式是保存在 Certificate Extension 內部。</p>
<p>All EV certificates have Certificate Policy: 2.23.140.1.1
Most OV certificates have Certificate Policy: 2.23.140.1.2.2
Most DV certificates have Certificate Policy: 2.23.140.1.2.1</p>
<p>但用數字不是很好判斷 OV 跟 DV，所以可以直接看 Subject 內的 Organization 是否有內容，DV 的 Organization 會是空值。</p>
<h2 id="certificate-revocation-1545">4.8 Certificate Revocation (15:45)</h2>
<p>之前有討論過 Certificate 是共享的，所以任何人都盜用 Certificate 並假裝自己是真的 Server，但是沒有真的 Private Key 所以握手過程會失敗，
但是如果連 Private Key 都被盜用了，那最後的防線也被突破了，也就讓這台偽造的 Server 變成真的 Server。</p>
<p>所以這種情況真的 Server 需要先建立新的 Public Key/Private Key，並用新的 Key 去申請新憑證，並撤銷被盜用的憑證。</p>
<p>撤銷憑證有幾種方式:
CRL: Certificate Revocation List
OCSP: Online Certificate Status Protocol
OCSP Stapling</p>
<h3 id="crl">CRL</h3>
<p>CRL 就是一組由 CA 維護的撤銷清單，我們能在憑證內部的 Extension 找到 CRL 欄位，這裡會記錄一個網址連線到 CA 的清單中。</p>
<p>這份 CRL 會包含被撤銷憑證的 Serial # 和撤銷日期，有些 CRL 還會提供撤銷的原因。</p>
<p>所以當 Client 接收到 Server 傳回的 Certificate Chain 之後會前往 CRL 標記的網址並下載清單，接下來 Client 根據憑證的 Serial #
前往 CRL 清單搜尋，如果能在 CRL 找到內容就代表這個憑證不能被相信。</p>
<p>但是 CRL 的缺點就是非常大而且很慢，並且這個清單內容不是即時更新的，可能會 5 ~ 14 天更新一次，所以假網站至少可以多活兩個禮拜，
並且最大的問題是有些瀏覽器會為了速度忽略 CRL 檢查。</p>
<p>瀏覽器將這份清單保留在本地，能夠有更快速的檢查過程
Chrome: CRLSet
Firefox: oneCRL</p>
<h3 id="ocsp">OCSP</h3>
<p>所以就有了改良版的檢查方式 OCSP，原理是 CA 要自己維護一台 OCSP Responder，之後瀏覽器要檢查憑證就不用下載整個清單，並且慢慢搜尋，
改良後只需要傳送 Serial # 給 OCSP Responder，就能直接知道憑證的狀態，並且更新是即時的不需要等 5 ~ 14 天。</p>
<p>我們能在憑證內部的 Extension 找到 OCSP 欄位，這裡會記錄一個網址能夠連線到 OCSP Responder。</p>
<p>這個過程是透過 Http 來發送檢查請求的，從 OCSP Responder 回傳狀態給 Client 的途中可能會被攔截結果，並且把驗證結果修改掉在回傳給 Client，
所以回傳的過程是用 CA 會把憑證狀態使用 CA Private Key 簽名，這樣回傳給 Client 就能保證結果沒有被修改過。</p>
<p>但是 OCSP 還是有缺點，第一個就是 Server 的隱私會被 CA 知道，因為每個點擊都要訪問一次 OCSP Responder，這樣 CA 就會知道 Server 會有多少的訪問量，
第二個就是 CA 會知道 Client 的訪問歷史紀錄，第三個就是 OCSP Responder 需要非常穩定不然訪問 Server 就會受阻，第四點是 Http 請求可能會被攔截，
雖然不能修改內容，但是中間人可以直接把你的檢查請求擋下來。</p>
<h3 id="ocsp-stapling">OCSP Stapling</h3>
<p>為了改進 OCSP 的缺點，所以就發明出另外一種操作 OCSP 的流程。
就是把 Client 訪問 OCSP Responder 改成從 Server 訪問 OCSP Responder，
Server 會間隔一段時間訪問 OCSP Responder，並且將憑證的狀態保存在 Server 的快取中，
之後 Client 訪問 Server 時，Server 需要同時提供 Certificate Chain 與快取的憑證狀態，
由於快取的憑證狀態有 CA 的簽名做保證，所以不用擔心被修改，
最後 Client 將獲取到的資料進行檢查。</p>
<p>優點是 OCSP Responder 可以把流量分散給更多的 Server 身上，這樣 OCSP Responder 就不用壓力這麼大，另外 Client 就不需要連線到 OCSP Responder，
就代表 Client 的操作紀錄就不會被 CA 得知了。</p>
<p>並且把負責安全性的責任交給 Server 負責，而不是交給 Client 自己負責，很多 Client 只會追求速度並忽略安全性。</p>
<h2 id="checking-revocation-status-1840">4.9 Checking Revocation Status (18:40)</h2>
<p>使用 openssl 來實際操作三種憑證撤銷方式。</p>
<h3 id="crl-certificate-revocation-list">CRL — Certificate Revocation List</h3>
<ol>
<li>Retrieve Certificate</li>
<li>Retrieve CRL</li>
<li>Look for Serial#</li>
</ol>
<pre><code class="language-text">openssl s_client -connect revoked.badssl.com:443
vi revoked.badssl.cert
openssl x509 -in revoked.badssl.cert -noout -text
weget http://crl3.digicert.com/ssca-sha2-g6.crl

openssl crl -in ssca-sha2-g6.crl -inform DER
openssl crl -in ssca-sha2-g6.crl -inform DER -noout -text &gt; crl-rovoked.badssl.com

cat crl-revoked.badssl.com | grep Reason -A1 | sort | uniq -c | sort -n

openssl x509 -in revoked.badssl.cert -noout -serial
cat crl-revoked.badssl.com | grep 045D831196093C3CE4F30C73932739E98A35 -C6
</code></pre>
<h3 id="ocsp-online-certificate-status-protocol">OCSP — Online Certificate Status Protocol</h3>
<ol>
<li>Retrieve Certificate</li>
<li>Find OCSP Responder</li>
<li>Make OCSP request</li>
</ol>
<pre><code class="language-text">openssl x509 -in revoked.badssl.cert -noout -text
Authority Information Access:
                OCSP - URI:http://ocsp.digicert.com
                CA Issuers - URI:http://cacerts.digicert.com/DigiCertSHA2SecureServerCA.crt
                
wget http://cacerts.digicert.com/DigiCertSHA2SecureServerCA.crt
openssl x509 -in DigiCertSHA2SecureServerCA.crt -inform DER -noout -text

openssl ocsp -url http://ocsp.digicert.com -issuer ca-badssl-cert -cert revoked.badssl.cert
openssl ocsp -url http://ocsp.digicert.com -issuer ca-badssl-cert -cert revoked.badssl.cert -no_nonce
</code></pre>
<h3 id="ocsp-stapling-1">OCSP Stapling</h3>
<ol>
<li>Retrieve Certificate and request Status</li>
</ol>
<pre><code class="language-text">openssl s_client -connect revoked.badssl.com:443
openssl s_client -connect revoked.badssl.com:443 -status
    OCSP response: no response sent //網站不支援
    
    
openssl s_client -connect example.com:443 -status

    OCSP response:
======================================
OCSP Response Data:
    OCSP Response Status: successful (0x0)
    Response Type: Basic OCSP Response
    Version: 1 (0x0)
    Responder Id: 748580C066C7DF37DECFBD2937AA031DBEEDCD17
    Produced At: Dec  6 17:07:16 2024 GMT
    Responses:
    Certificate ID:
      Hash Algorithm: sha1
      Issuer Name Hash: A7C4B8B3DC5BB5581EA7D7F13AC569F56F48D789
      Issuer Key Hash: 748580C066C7DF37DECFBD2937AA031DBEEDCD17
      Serial Number: 075BCEF30689C8ADDF13E51AF4AFE187
    Cert Status: good
    This Update: Dec  6 16:51:02 2024 GMT
    Next Update: Dec 13 15:51:02 2024 GMT

    Signature Algorithm: sha256WithRSAEncryption
    Signature Value:
        65:4d:29:92:46:ed:cc:5d:20:67:83:44:26:5c:c6:60:16:14:
        92:3b:ac:51:68:6c:ef:55:15:9e:a8:62:bc:77:15:ee:fb:0d:
        fc:0c:34:0c:e0:91:af:c1:11:a6:6b:19:35:56:23:c4:1c:b5:
        19:02:5a:ce:d7:61:7e:a4:fa:9b:80:c5:62:f6:c5:f4:d8:4e:
        49:58:0d:1a:b3:62:95:62:98:58:6f:f8:17:71:6f:bb:b2:2c:
        ec:73:9c:6d:cd:b1:38:e9:90:cd:34:37:24:a5:1b:e3:2c:03:
        c8:c2:7b:0e:8a:aa:f8:95:be:db:bc:db:b7:14:48:07:d0:47:
        94:1c:93:bf:d2:bc:ca:42:63:fa:c7:ba:42:2f:53:64:13:e1:
        33:b7:78:53:0c:fd:80:dc:81:d9:29:ca:e1:5a:b8:f5:87:a9:
        5b:84:10:20:25:aa:bd:3d:27:c9:db:77:ae:ff:32:c1:51:35:
        0f:38:c3:b9:50:2d:6d:7e:ed:d0:25:de:22:31:b1:f9:38:ac:
        5a:4b:af:65:5f:25:52:ae:b8:b6:5b:0e:6e:7c:47:62:82:4a:
        9c:f3:d0:61:ad:82:db:fc:d8:ce:27:fe:75:b9:2a:da:30:0b:
        fd:d3:74:ac:ce:61:5b:cf:89:27:8e:62:ad:39:a4:2c:d9:f6:
        b4:16:02:89
======================================
</code></pre>
<h2 id="module-4-review-questions">4.10 Module 4 Review Questions</h2>
<ul>
<li>What are two questions a Client must ask when receiving a Certificate from a Server?</li>
</ul>
<ol>
<li>檢查收到的 Certificate 是否具有合法效力。</li>
<li>檢查收到的 Certificate 是否是真的 Server 傳過來的。</li>
</ol>
<ul>
<li>How does the Client validate that a Certificate can be trusted?
CA 會對 Certificate 進行簽名，所以 Client 收到的時候使用 CA 的 Public Key 能成功解密就是可信。</li>
<li>How does the Client validate that the Server is the true owner of a Certificate?
<ul>
<li>Why is this question important if the prior question has already been answered?
因為 Certificate 任何人都可以下載，所以可以假裝自己是真的 Server。</li>
<li>What are the two methods the Client answers this question? What are the two results which occur with either method?
<code>Client Initiated</code> 由 Client 先發起請求，並產生一個隨機值與 Session Key，將隨機值使用 Server Public Key 加密後傳給 Server，
如果 Server 是真的 Server 那他就有 Private Key 能夠成功解密，並建立同樣的 Session Key，並開始溝通。
<code>Server Initiated</code> 由 Server 端先發起請求，並產生一個隨機值與 Session Key，將隨機值使用 Server Private Key 簽名後傳送給 Client，
Client 接收到後可以使用 Server 的 Public Key 進行簽名檢查，並建立同樣的 Session Key，並開始溝通，
產生 Session Key 時還需要一些只有正確 Client 才知道的值才能確保與正確的 Client 進行連線。</li>
<li>What determines which method gets used?
如果要用加密解密的方式就用 <code>Client Initiated</code>。
如果要用簽名的方式就用 <code>Server Initiated</code>。</li>
</ul>
</li>
<li>What is the benefit of Intermediate CA’s instead of a single Root CA?
可以讓 Root CA 把簽發憑證的工作分散給 ICA 這樣就可以避免 Root CA 的 Private Key 外流。</li>
<li>How does an Intermediate CA acquire its certificate?
ICA 也要透過 CSR 申請憑證，需要將 CSR 傳送給 Chain 中的上一級 CA 或 ICA。</li>
<li>How does a Client signify its trust of a particular Root CA?
瀏覽器安裝的時候會內建 Root CA 的憑證。</li>
<li>What is a Certificate Chain? How does it work?
由多個 CA 與 ICA 組成的，透過 Issuer 與 Subject 可以建立出 Certificate Chain。</li>
<li>Which Certificates should the Server send to the Client?
要把 Chain 中所有的 ICA 與 末端的 Certificate 傳送給 Client。</li>
<li>What problem is the Basic Constraints extension trying to solve?
<ul>
<li>What mechanism(s) does it use to solve these problems?
<code>Basic Constraints</code> 限制憑證是否是 CA 以及 ICA 最大的深度。</li>
</ul>
</li>
<li>What are Domain Validation certificates? What are Extended Validation certificates?
<ul>
<li>Which are more secure?
DV 跟 OV 跟 EV 一樣安全，只是獲得的難度不一樣。</li>
</ul>
</li>
<li>What is the process for revocation using a Certificate Revocation List (CRL)?
<ul>
<li>What are the problems with this process?
CRL 要用來驗證憑證是否撤銷，但 CRL 清單太長所以檢查速度很慢，並且不會即時更新，而且有些瀏覽器會為了速度跳過 CRL 檢查。</li>
</ul>
</li>
<li>What is the process for revocation using OCSP?
<ul>
<li>What are the problems with this process?
OCSP 修正了 CRL 的問題，Client 發起 Http 請求給 OCSP Responder 檢查 Serial # 是否被撤銷，
但是隱私性會被 CA 知道，OCSP Responder 需要非常穩定不然訪問 Server 就會受阻，
中間人可以直接把你的 Http 檢查請求擋下來。</li>
</ul>
</li>
<li>What is the process for revocation using OCSP Stapling?
修正 OCSP 的缺點，把與 OCSP Responder 溝通的責任改成 Server 負責，這樣 Client 跟 Server 溝通時
就可以把 Certificate 與 Status 一起取得，Client 就不用連線到 OCSP Responder 了。</li>
</ul>

        

      </div>
    </div>
  </div>

  <hr>

  <!-- Footer -->
  <footer>
  <div class="container">
    <div class="row">
      <div class="col-md-12 text-center">
        <p class="copyright">&#xA9; 2024 by Allen Gao</p>

      </div>
    </div>
  </div>
</footer>


  <!-- Scripts -->
  <script async src='/vendor/bootstrap/js/bootstrap.bundle.min1.js'></script>
  <script async src='/vendor/startbootstrap-clean-blog/js/scripts.js'></script>
  

  

</body>

</html>
