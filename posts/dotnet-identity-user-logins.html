<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="preload" as="style" href='/scss/clean-blog-min.css'/>

    <meta name="description" content="7.&#x81EA;&#x8A02;.NET Core Identity&#x8EAB;&#x4EFD;&#x9A57;&#x8B49;&#x548C;&#x6388;&#x6B0A;&#x6559;&#x5B78;&#xFF1A;AspNetUserLogins">

  <title>&#x81EA;&#x8A02;.NET Core Identity&#x8EAB;&#x4EFD;&#x9A57;&#x8B49;&#x548C;&#x6388;&#x6B0A;&#x6559;&#x5B78;&#xFF1A;AspNetUserLogins</title>


  <link rel="canonical" href='https://blog.allengaodev.com/posts/dotnet-identity-user-logins'>

      <link type="application/rss+xml" rel="alternate" title="&#x958B;&#x767C;&#x7A7A;&#x9593;" href="/feed.rss" />
      <link type="application/atom+xml" rel="alternate" title="&#x958B;&#x767C;&#x7A7A;&#x9593;" href="/feed.atom" />

  <meta name="application-name" content='Gao.Dev' />
  <meta name="msapplication-tooltip" content='Gao.Dev' />
  <meta name="msapplication-starturl" content='/' />
  <meta name="google-site-verification" content="aq71qXzppLuXZ8be8mjOwn_zJq317ZSD34yTS4i6y6M" />
  <meta property="og:title" content='&#x81EA;&#x8A02;.NET Core Identity&#x8EAB;&#x4EFD;&#x9A57;&#x8B49;&#x548C;&#x6388;&#x6B0A;&#x6559;&#x5B78;&#xFF1A;AspNetUserLogins' />
  <meta property="og:type" content="website" />
  <meta property="og:url" content='https://blog.allengaodev.com/posts/dotnet-identity-user-logins' />

  <link rel="icon" href='/favicon.svg'>

  <!-- Styles for this template (also includes Bootstrap) -->
  <link href='/scss/clean-blog-min.css' rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.css" rel="stylesheet" media="print" onload="this.media='all'">

  


  

</head>

<body>

  <!-- Navigation -->
  <nav class="navbar navbar-expand navbar-light" id="mainNav" style="background-color: #F5F1E6">
  <div class="container">
    <a class="navbar-brand text-dark" href='/'> Home </a>

    <div class="navbar-nav-container" id="navbarResponsive">
      <ul class="navbar-nav ms-auto">
          <li class="nav-item">
    <a class="nav-link text-dark" href="/search">Search</a>
  </li>
  <li class="nav-item">
    <a class="nav-link text-dark" href="/posts">Posts</a>
  </li>
  <li class="nav-item">
    <a class="nav-link text-dark" href="/tags">Tags</a>
  </li>

      </ul>
    </div>
  </div>
</nav>


  <!-- Page Header -->
  <header class="masthead no-image">
  <div class="container position-relative">
    <div class="row">
      <div class="col-md-12">
        <div class='post-heading'>
          <h1>
            <a style="color:white" href='https://blog.allengaodev.com/posts/dotnet-identity-user-logins'>&#x81EA;&#x8A02;.NET Core Identity&#x8EAB;&#x4EFD;&#x9A57;&#x8B49;&#x548C;&#x6388;&#x6B0A;&#x6559;&#x5B78;&#xFF1A;AspNetUserLogins</a>
          </h1>
            <p class="post-meta">
              <a style="line-height: 1.8em;padding-left: 1.6em;background-size: auto 100%;background-repeat: no-repeat; background-image:url(/calendar.svg)">
                2023/04/26
              </a>

                <a style="line-height: 1.8em;padding-left: 1.6em;background-size: auto 100%;background-repeat: no-repeat; background-image:url(/overtime.svg)">
                  2025/08/21
                </a>
            </p>
              <div class="mt-3">
                  <a href="/tags/dotnet" class="badge bg-white text-dark"> Dotnet</a>
                  <a href="/tags/csharp" class="badge bg-white text-dark"> CSharp</a>
                  <a href="/tags/identity" class="badge bg-white text-dark"> Identity</a>
              </div>
        </div>
      </div>
    </div>
  </div>
</header>


  <!-- Main Content -->
  <main id="main-content">
    <div class="container">
      <div class="row">
        <div id="content" class="col-md-12">
          <h2 id="net-core-identity-aspnetuserlogins">.NET Core Identity AspNetUserLogins</h2>
<p>我們在上一篇的文章中新增了 Google 外部登入到我們專案內，但有一個很大的問題就是外部登入的會員沒有在我們的系統內進行註冊
所以判斷權限時會找不到對應的會員權限，要解決這個問題我們可以在外部登入流程中插入一段註冊本地會員的邏輯</p>
<p>開始寫程式之前我們先了解一下 .NET Core Identity 內建的 Class <code>IdentityUserLogin</code><br />
我們之前已經學習過<code>IdentityUser</code> 和 <code>IdentityUserClaim</code> 現在要學習的 <code>IdentityUserLogin</code> 從名稱來看不是很好理解
第一眼看很像是負責紀錄會員登入次數的表，我們先看看 <a href="https://github.com/dotnet/aspnetcore/blob/main/src/Identity/Extensions.Stores/src/IdentityUserLogin.cs" target="_blank">Github</a></p>
<pre><code class="language-text">/// &lt;summary&gt;
/// Represents a login and its associated provider for a user.
/// &lt;/summary&gt;
/// &lt;typeparam name=&quot;TKey&quot;&gt;The type of the primary key of the user associated with this login.&lt;/typeparam&gt;
public class IdentityUserLogin&lt;TKey&gt; where TKey : IEquatable&lt;TKey&gt;
{
    /// &lt;summary&gt;
    /// Gets or sets the login provider for the login (e.g. facebook, google)
    /// &lt;/summary&gt;
    public virtual string LoginProvider { get; set; } = default!;

    /// &lt;summary&gt;
    /// Gets or sets the unique provider identifier for this login.
    /// &lt;/summary&gt;
    public virtual string ProviderKey { get; set; } = default!;

    /// &lt;summary&gt;
    /// Gets or sets the friendly name used in a UI for this login.
    /// &lt;/summary&gt;
    public virtual string? ProviderDisplayName { get; set; }

    /// &lt;summary&gt;
    /// Gets or sets the primary key of the user associated with this login.
    /// &lt;/summary&gt;
    public virtual TKey UserId { get; set; } = default!;
}
</code></pre>
<p>從註解中可以了解到這個 Class 是用來對應外部登入的會員與內部會員的表，可以猜測到表內會有以下類似的內容</p>
<pre><code class="language-text">LoginProvider = &quot;Google&quot;
ProviderKey = &quot;112873593891211851878&quot;
ProviderDisplayName = &quot;Allen Gao&quot;
UserId = &quot;c905d70c-d538-4190-b30a-5a0928dbee0f&quot;
</code></pre>
<p>這邊 <code>ProviderKey</code> 為外部系統提供的唯一編號，以 Google 為例，登入成功後 HttpContext 的 Claim 會新增 nameidentifier 代表 Google 內部的唯一會員編號，
另外是 <code>UserId</code> 是我們對應內部系統的會員唯一編號，以我們的系統為例就是回傳一個 <code>GUID</code></p>
<p>所以根據以上信息我們需要完成兩件事情</p>
<ol>
<li>在會員按下同意授權後 Google 會呼叫 redirect URI 之後由 GoogleHandler 進行處理，我們需要想辦法在這段邏輯中插入我們的註冊程式碼</li>
<li>運行我們註冊程式碼時需要將對應資料新增到 IdentityUserLogin 表</li>
</ol>
<p>首先建立 <code>IdentityUserLogin</code> 資料表</p>
<pre><code class="language-text">CREATE TABLE dbo.AspNetUserLogins (
    LoginProvider character varying(128) NOT NULL,
    ProviderKey character varying(128) NOT NULL,
    ProviderDisplayName text NULL,
    UserId text NOT NULL,
    CONSTRAINT PK_AspNetUserLogins PRIMARY KEY (LoginProvider, ProviderKey),
    CONSTRAINT FK_AspNetUserLogins_AspNetUsers_UserId FOREIGN KEY (UserId) REFERENCES dbo.AspNetUsers (Id) ON DELETE CASCADE
);

CREATE INDEX IX_AspNetUserLogins_UserId ON dbo.AspNetUserLogins (UserId);
</code></pre>
<p>並且到 <code>CustomUserStore</code> 實做新界面 <code>IUserLoginStore&lt;IdentityUser&gt;</code>，當使用第三方登入時需要先用 <code>FindByLoginAsync</code> 檢查這個第三方會員是否在本地建立資料過，
沒有的話才使用 <code>AddLoginAsync</code> 建立新的本地會員</p>
<p>跟 <code>IUserClaimStore</code> 一樣，我們也需要實做 <code>IUserLoginStore</code> 介面這樣才能知道要怎麼存取 <code>aspnetuserlogins</code> 資料表</p>
<pre><code class="language-text">public async Task AddLoginAsync(IdentityUser user, UserLoginInfo login, CancellationToken cancellationToken)
{
    if (user == null) throw new ArgumentNullException(nameof(user));
    if (login == null) throw new ArgumentNullException(nameof(login));

    var connString = _configuration.GetSection(&quot;ConnectionStrings&quot;).GetValue&lt;string&gt;(&quot;DefaultConnection&quot;);
    await using var conn = new NpgsqlConnection(connString);
    await conn.OpenAsync(cancellationToken);

    // 使用小寫表名及欄位名
    var command = &#64;&quot;
    INSERT INTO dbo.aspnetuserlogins (loginprovider, providerkey, providerdisplayname, userid)
    VALUES (&#64;LoginProvider, &#64;ProviderKey, &#64;ProviderDisplayName, &#64;UserId)
    ON CONFLICT (loginprovider, providerkey) DO NOTHING;
&quot;;

    var parameters = new
    {
        LoginProvider = login.LoginProvider,
        ProviderKey = login.ProviderKey,
        ProviderDisplayName = login.ProviderDisplayName,
        UserId = Guid.Parse(user.Id)
    };

    await conn.ExecuteAsync(command, parameters);
}

    public async Task&lt;IdentityUser?&gt; FindByLoginAsync(string loginProvider, string providerKey, CancellationToken cancellationToken)
{
    var connString = _configuration.GetSection(&quot;ConnectionStrings&quot;).GetValue&lt;string&gt;(&quot;DefaultConnection&quot;);
    await using var conn = new NpgsqlConnection(connString);
    await conn.OpenAsync();

    await using (var sqlConnection = conn)
    {
        var command = $&quot;SELECT UserId &quot; +
                      $&quot;FROM dbo.AspNetUserLogins &quot; +
                      &quot;WHERE LoginProvider = &#64;LoginProvider AND ProviderKey = &#64;ProviderKey;&quot;;

        var userId = await sqlConnection.QuerySingleOrDefaultAsync&lt;string?&gt;(command, new {
            LoginProvider = loginProvider,
            ProviderKey = providerKey
        });

        if (userId == null) {
            return null;
        }

        command = &quot;SELECT * FROM dbo.AspNetUsers WHERE Id = &#64;Id;&quot;;

        return await sqlConnection.QuerySingleAsync&lt;IdentityUser&gt;(command, new { Id = userId });
    }
}
</code></pre>
<p>最後到 <code>AccountController</code> 新增 <code>LoginGoogle</code>、<code>GoogleResponse</code> 方法，<code>LoginGoogle</code> 方法跟上一篇寫的 <code>ExternalSignin</code> 方法意思一樣，
只是這次改用 <code>ControllerBase.Challenge</code> 底層的邏輯都是一致的，最後都會轉跳到 Google 登入。</p>
<p>另外這裡設定了 <code>redirectUrl</code> 讓我們在 <code>https://localhost:7011/signin-google</code> 執行完成後轉跳到另一個 API(<code>GoogleResponse</code>)來設定本地的會員資料。</p>
<pre><code class="language-csharp">[HttpGet(&quot;LoginGoogle&quot;)]
public IActionResult LoginGoogle(string returnUrl = &quot;/&quot;)
{
    var redirectUrl = Url.Action(&quot;GoogleResponse&quot;, &quot;Account&quot;, new { returnUrl });
    var properties = _signInManager.ConfigureExternalAuthenticationProperties(&quot;Google&quot;, redirectUrl);
    return Challenge(properties, &quot;Google&quot;);
}
</code></pre>
<p>這個階段 .Net 將會把會員的資料設定到 <code>IdentityConstants.ExternalScheme</code> 這個 cookie 裡面，
這時 <code>SignInManager.GetExternalLoginInfoAsync</code> 可以透過 HttpContext 來讀取 <code>IdentityConstants.ExternalScheme</code> 的內容，
也就是說 info 變數目前就是儲存著第三方登入的結果。</p>
<p>目前確認第三方登入已經登入成功了，並且 <code>IdentityConstants.ExternalScheme</code> 這個外部登入的 cookie 也有資料，不過我們的網站真正需要的是
<code>IdentityConstants.ApplicationScheme</code> 這個 cookie，所以目前只完成了一半的流程，接下來就要使用 <code>SignInManager.ExternalLoginSignInAsync</code> 方法
進行本地登入，看過原始碼後會發現這個方法其實就跟 <code>SignInManager.PasswordSignInAsync</code> 非常相似，差別就在於一個需要密碼一個不用而已，
這是因為外部登入已經在 Google 平台驗證過密碼了，所以我們網站只需要直接登入綁定的會員即可，下面的 LoginProvider 就是 Google，
ProviderKey 就是會員的編號可以理解成帳號。</p>
<p>最後如果在資料庫找不到會員的話就幫忙新增一個新的本地會員並直接登入。</p>
<pre><code class="language-csharp">[HttpGet(&quot;GoogleResponse&quot;)]
public async Task&lt;IActionResult&gt; GoogleResponse(string returnUrl = &quot;/&quot;)
{
    var info = await _signInManager.GetExternalLoginInfoAsync();
    if (info == null)
    {
        return RedirectToAction(&quot;LoginGoogle&quot;); // 重新嘗試
    }

    // 嘗試登入現有帳號
    var signInResult = await _signInManager.ExternalLoginSignInAsync(info.LoginProvider, info.ProviderKey, false);

    if (!signInResult.Succeeded)
    {
        // 如果帳號不存在，就建立一個新使用者
        var email = info.Principal.FindFirstValue(System.Security.Claims.ClaimTypes.Email);
        var user = new IdentityUser { UserName = email, Email = email };

        var result = await _userManager.CreateAsync(user);
        if (result.Succeeded)
        {
            await _userManager.AddLoginAsync(user, info);
            await _signInManager.SignInAsync(user, isPersistent: false);
        }
        else
        {
            return BadRequest(result.Errors);
        }
    }

    return LocalRedirect(returnUrl);
}
</code></pre>
<p>最後是 <code>Program.cs</code> 的完整設定，需要確認 <code>IdentityConstants.ExternalScheme</code> 有對應的儲存方式，這裡選擇的是用 cookie 來保存，
如果少了這一行代表外部的登入結果找不到地方保存，後續的登入流程無法繼續。</p>
<pre><code class="language-text">.AddAuthentication(o =&gt;
{
    o.DefaultScheme = IdentityConstants.ApplicationScheme;
})
.AddCookie(IdentityConstants.ExternalScheme, o =&gt;
{
    o.ExpireTimeSpan = TimeSpan.FromMinutes(10);
})
.AddGoogle(GoogleDefaults.AuthenticationScheme, o =&gt;
{
    o.ClientId = configuration[&quot;Authentication:Google:ClientId&quot;];
    o.ClientSecret = configuration[&quot;Authentication:Google:ClientSecret&quot;];
    o.SignInScheme = IdentityConstants.ExternalScheme;
});
</code></pre>
<p>完成後 Get <code>LoginGoogle</code> 測試整體流程，成功後能在 <code>aspnetusers</code> 與 <code>aspnetuserlogins</code> 看到新的會員與第三方的綁定，最後在 Get
<code>ListHttpContextClaim</code> 確認 HttpContext 有設定成功。</p>
<p>有了這樣的架構如果之後增加 Facebook 或者其他登入時，因為會有另一組 LoginProvider(Facebook) 與 ProviderKey(292908172340981234878)
不需要在新增本地 User 所以只要直接寫入到 AspNetUserLogins，這樣就可以使用不同的 LoginProvider 登入到同一個本地 User</p>
<hr />
<h2 id="summary">Summary</h2>
<p>今天了解了 AspNetUserLogins 的運作原理，有了這個表後就可以同時使用許多種的外部登入方式而且只會對應到同一個本地使用者上，
並不會用 Google 登入就建立一個或用 Facebook 登入就建立一個，或者整個網站只支援一個外部登入方式。</p>


          

        </div>
      </div>
  <div id="comments-container" class="row">
    <div id="giscus-container"></div>

<script>
  let giscusLoaded = false;
  function loadGiscus() {
    if (giscusLoaded) return;
    giscusLoaded = true;

    let datarepo = 'allengaodev/allengaodev.github.io'
    let datarepoid='R_kgDOI6sF8g'
    let datacategoryid='DIC_kwDOI6sF8s4CUbuw'
    const script = document.createElement("script");
    script.src = "https://giscus.app/client.js";
    script.setAttribute('data-repo', datarepo);
    script.setAttribute('data-repo-id', datarepoid);
    script.setAttribute('data-category-id', datacategoryid);
    script.setAttribute("data-mapping", "pathname");
    script.setAttribute("data-strict", "0");
    script.setAttribute("data-reactions-enabled", "1");
    script.setAttribute("data-emit-metadata", "0");
    script.setAttribute("data-input-position", "top");
    script.setAttribute("data-theme", "light");
    script.setAttribute("data-lang", "en");
    script.async = true;
    document.getElementById("giscus-container").appendChild(script);
  }

  // 檢查是否滾動到最底部
  function checkScrollBottom() {
    if ((window.innerHeight + window.scrollY) >= document.body.offsetHeight / 2) {
      loadGiscus();
      window.removeEventListener("scroll", checkScrollBottom);
    }
  }

  // 等待滾動結束
  setTimeout(() => {
    checkScrollBottom();
    window.addEventListener("scroll", checkScrollBottom);
  }, 500); // 0.5秒後檢查
</script>

  </div>
    </div>
  </main>

  <hr>

  <!-- Footer -->
  <footer>
  <div class="container">
    <div class="row">
      <div class="col-md-12 text-center">
        <p class="copyright">&#xA9; 2025 by Allen Gao</p>

      </div>
    </div>
  </div>
</footer>


  <!-- Scripts -->
  <script defer src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/js/bootstrap.min.js"></script>
  <script async src="https://cdn.jsdelivr.net/npm/quicklink@2.3.0/dist/quicklink.umd.js"></script>
  <script defer src='/vendor/startbootstrap-clean-blog/js/scripts.min.js'></script>
  

  
</body>

</html>
