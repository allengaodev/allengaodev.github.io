<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="preload" as="image" href="/assets/img/101night.avif" fetchpriority="high">
  <link rel="preconnect" href="https://giscus.app" crossorigin>
  <link rel="preload" as="style" href='/scss/clean-blog.css'/>

    <meta name="description" content="&#x89E3;&#x6790; ABP.IO &#x7684; AOP &#x6514;&#x622A;&#x5668;&#x8A2D;&#x8A08;&#xFF0C;&#x8AAA;&#x660E; ABP &#x5982;&#x4F55;&#x900F;&#x904E; Castle Core &#x8207; Autofac &#x5BE6;&#x73FE;&#x975E;&#x540C;&#x6B65;&#x6514;&#x622A;&#x6D41;&#x7A0B;&#xFF0C;&#x4E26;&#x4EE5; UnitOfWorkInterceptor &#x70BA;&#x4F8B;&#xFF0C;&#x5B8C;&#x6574;&#x62C6;&#x89E3;&#x6514;&#x622A;&#x5668;&#x8A3B;&#x518A;&#x3001;&#x8F49;&#x63A5;&#x5C64;&#x8A2D;&#x8A08;&#x8207;&#x5BE6;&#x969B;&#x8ACB;&#x6C42;&#x57F7;&#x884C;&#x9806;&#x5E8F;&#xFF0C;&#x5354;&#x52A9;&#x7406;&#x89E3; ABP AOP &#x7684;&#x6574;&#x9AD4;&#x904B;&#x4F5C;&#x539F;&#x7406;&#x3002;">

  <title>ABP IO &#x67B6;&#x69CB;&#x5206;&#x6790; &#x2013; AOP &#x6514;&#x622A;&#x5668;</title>


  <link rel="canonical" href='https://blog.allengaodev.com/posts/abp-io-interceptors'>

      <link type="application/rss+xml" rel="alternate" title="&#x958B;&#x767C;&#x7A7A;&#x9593;" href="/feed.rss" />
      <link type="application/atom+xml" rel="alternate" title="&#x958B;&#x767C;&#x7A7A;&#x9593;" href="/feed.atom" />

  <meta name="application-name" content='Gao.Dev' />
  <meta name="msapplication-tooltip" content='Gao.Dev' />
  <meta name="msapplication-starturl" content='/' />
  <meta name="google-site-verification" content="aq71qXzppLuXZ8be8mjOwn_zJq317ZSD34yTS4i6y6M" />
  <meta property="og:title" content='ABP IO &#x67B6;&#x69CB;&#x5206;&#x6790; &#x2013; AOP &#x6514;&#x622A;&#x5668;' />
    <meta property="og:image" content='/assets/img/101night.avif' />
  <meta property="og:type" content="website" />
  <meta property="og:url" content='https://blog.allengaodev.com/posts/abp-io-interceptors' />

  <link rel="icon" href='/favicon.svg'>

  <!-- Styles for this template (also includes Bootstrap) -->
  <link href='/scss/clean-blog.css' rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.css" rel="stylesheet" media="print" onload="this.media='all'">

  


  

</head>

<body>

  <!-- Navigation -->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav" style="background-color: #F5F1E6">
  <div class="container">
    <a class="navbar-brand text-dark" href='/'> Home </a>
    <button class="navbar-toggler navbar-toggler-right text-dark" type="button" data-bs-toggle="collapse" data-bs-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
      Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ms-auto">
          <li class="nav-item">
    <a class="nav-link text-dark" href="/search">Search</a>
  </li>
  <li class="nav-item">
    <a class="nav-link text-dark" href="/posts">Posts</a>
  </li>
  <li class="nav-item">
    <a class="nav-link text-dark" href="/tags">Tags</a>
  </li>

      </ul>
    </div>
  </div>
</nav>


  <!-- Page Header -->
  <header class="masthead" style="background-image: url(&quot;/assets/img/101night.avif&quot;)">
  <div class="container position-relative">
    <div class="row">
      <div class="col-md-12">
        <div class='post-heading'>
          <h1>
            <a style="color:white" href='https://blog.allengaodev.com/posts/abp-io-interceptors'>ABP IO &#x67B6;&#x69CB;&#x5206;&#x6790; &#x2013; AOP &#x6514;&#x622A;&#x5668;</a>
          </h1>
            <p class="post-meta">
              <a style="line-height: 1.8em;padding-left: 1.6em;background-size: auto 100%;background-repeat: no-repeat; background-image:url(/calendar.svg)">
                2025/12/18
              </a>

            </p>
              <div class="mt-3">
                  <a href="/tags/abp" class="badge text-bg-light text-dark"> ABP</a>
                  <a href="/tags/castle" class="badge text-bg-light text-dark"> Castle</a>
                  <a href="/tags/autofac" class="badge text-bg-light text-dark"> Autofac</a>
              </div>
        </div>
      </div>
    </div>
  </div>
</header>


  <!-- Main Content -->
  <main id="main-content">
    <div class="container">
      <div class="row">
        <div id="content" class="col-md-12">
          <h2 id="abp">ABP 攔截器</h2>
<p>ABP 大量採用 AOP 設計將橫切關注點抽離到攔截器中，保持程式碼乾淨且易於維護。
底層利用 Castle Core 整合 Autofac 實現 AOP，但 ABP 為了避免直接依賴第三方函式庫，額外封裝了一層抽象，以便未來擴充。</p>
<p>Castle Core 與整合 Autofac 的基礎知識可以參考之前的文章:</p>
<ul>
<li><strong><a href="https://blog.allengaodev.com/posts/castle-core-basic" target="_blank"><u>01.Castle Core 模組介紹：Logging、DictionaryAdapter 與 DynamicProxy 實作</u></a></strong></li>
<li><strong><a href="https://blog.allengaodev.com/posts/castle-core-with-autofac" target="_blank"><u>02.Castle Core 與 Autofac 整合應用</u></a></strong></li>
</ul>
<p><br><br></p>
<hr />
<h2 id="section">核心概念</h2>
<p>以下是幾個關鍵的知識點:</p>
<ol>
<li>函式庫依賴
<ul>
<li><code>Castle.Core</code>：提供 DynamicProxy，實現攔截功能。</li>
<li><code>Castle.Core.AsyncInterceptor</code>：簡化非同步攔截器實作。</li>
<li><code>Autofac.Extras.DynamicProxy</code>：將 Castle DynamicProxy 整合進 Autofac DI。</li>
<li><code>Autofac.Extensions.DependencyInjection</code>：使用 Autofac 替代原生 DI。</li>
</ul>
</li>
<li>攔截器流程
<ul>
<li><code>Castle.Core</code> 攔截器呼叫 <code>invocation.Proceed()</code> 回到原流程並執行原始方法。</li>
<li><code>Castle.Core.AsyncInterceptor</code> 建立的非同步攔截器透過 <code>AsyncDeterminationInterceptor</code> 將 <code>IAsyncInterceptor</code> 包裝成 <code>IInterceptor</code>。</li>
<li><code>AsyncDeterminationInterceptor</code> 內部會自動判斷攔截的方法是 <code>Synchronous</code>、<code>AsyncAction</code>、<code>AsyncFunction</code> 三個其中一種，並呼叫對應攔截程式。</li>
<li><code>Autofac.Extras.DynamicProxy</code> 只看得懂 <code>IInterceptor</code> 介面。</li>
<li><code>EnableInterfaceInterceptors()</code>、<code>EnableClassInterceptors()</code> 分別用於介面與類別的攔截。</li>
<li><code>InterceptedBy</code> 需要指定獨立類別名稱以區分不同攔截器。</li>
</ul>
</li>
<li>非同步攔截器實作方式(底層都是實作 <code>IAsyncInterceptor</code>)
<ul>
<li>實作 <code>IAsyncInterceptor</code></li>
<li>繼承 <code>AsyncInterceptorBase</code></li>
<li>繼承 <code>ProcessingAsyncInterceptor&lt;TState&gt;</code></li>
</ul>
</li>
</ol>
<p><br><br></p>
<hr />
<h2 id="abp-1">建立 ABP 攔截器</h2>
<p>首先參考一下內建的 <code>UnitOfWorkInterceptor</code> 攔截器，它用來將當前請求包裝成一個事務：</p>
<ol>
<li>繼承 <code>AbpInterceptor</code> 並註冊為 Transient。</li>
<li>建立 <code>RegisterIfNeeded</code> 委派，透過 <code>ShouldIntercept()</code> 方法，判斷是否將此攔截器加入 <code>OnServiceRegistredContext.Interceptors</code>清單。</li>
<li>所有攔截器的 <code>RegisterIfNeeded</code> 委派集中到 <code>ServiceRegistrationActionList</code>，程式啟動時透過 <code>UseAutofac()</code> 方法依序執行所有委派完成註冊。</li>
</ol>
<p><br><br></p>
<h3 id="unitofworkinterceptor">UnitOfWorkInterceptor 核心程式碼</h3>
<pre><code class="language-csharp">using System;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Options;
using Volo.Abp.DependencyInjection;
using Volo.Abp.DynamicProxy;

namespace Volo.Abp.Uow;

public class UnitOfWorkInterceptor : AbpInterceptor, ITransientDependency
{
    private readonly IServiceScopeFactory _serviceScopeFactory;

    public UnitOfWorkInterceptor(IServiceScopeFactory serviceScopeFactory)
    {
        _serviceScopeFactory = serviceScopeFactory;
    }

    public override async Task InterceptAsync(IAbpMethodInvocation invocation)
    {
        if (!UnitOfWorkHelper.IsUnitOfWorkMethod(invocation.Method, out var unitOfWorkAttribute))
        {
            await invocation.ProceedAsync();
            return;
        }

        using (var scope = _serviceScopeFactory.CreateScope())
        {
            var options = CreateOptions(scope.ServiceProvider, invocation, unitOfWorkAttribute);

            var unitOfWorkManager = scope.ServiceProvider.GetRequiredService&lt;IUnitOfWorkManager&gt;();

            //Trying to begin a reserved UOW by AbpUnitOfWorkMiddleware
            if (unitOfWorkManager.TryBeginReserved(UnitOfWork.UnitOfWorkReservationName, options))
            {
                await invocation.ProceedAsync();

                if (unitOfWorkManager.Current != null)
                {
                    await unitOfWorkManager.Current.SaveChangesAsync();
                }

                return;
            }

            using (var uow = unitOfWorkManager.Begin(options))
            {
                await invocation.ProceedAsync();
                await uow.CompleteAsync();
            }
        }
    }

    private AbpUnitOfWorkOptions CreateOptions(IServiceProvider serviceProvider, IAbpMethodInvocation invocation, UnitOfWorkAttribute? unitOfWorkAttribute)
    {
        var options = new AbpUnitOfWorkOptions();

        unitOfWorkAttribute?.SetOptions(options);

        if (unitOfWorkAttribute?.IsTransactional == null)
        {
            var defaultOptions = serviceProvider.GetRequiredService&lt;IOptions&lt;AbpUnitOfWorkDefaultOptions&gt;&gt;().Value;
            options.IsTransactional = defaultOptions.CalculateIsTransactional(
                autoValue: serviceProvider.GetRequiredService&lt;IUnitOfWorkTransactionBehaviourProvider&gt;().IsTransactional
                           ?? !invocation.Method.Name.StartsWith(&quot;Get&quot;, StringComparison.InvariantCultureIgnoreCase)
            );
        }

        return options;
    }
}
</code></pre>
<p><br><br></p>
<h3 id="section-1">攔截器註冊</h3>
<pre><code class="language-csharp">using System;
using System.Reflection;
using Volo.Abp.DependencyInjection;
using Volo.Abp.DynamicProxy;

namespace Volo.Abp.Uow;

public static class UnitOfWorkInterceptorRegistrar
{
    public static void RegisterIfNeeded(IOnServiceRegistredContext context)
    {
        if (ShouldIntercept(context.ImplementationType))
        {
            context.Interceptors.TryAdd&lt;UnitOfWorkInterceptor&gt;(); // 加入到 `OnServiceRegistredContext` 的 `Interceptors` 清單中
        }
    }

    private static bool ShouldIntercept(Type type)
    {
        return !DynamicProxyIgnoreTypes.Contains(type) &amp;&amp; UnitOfWorkHelper.IsUnitOfWorkType(type.GetTypeInfo());
    }
}
</code></pre>
<pre><code class="language-csharp">using Microsoft.Extensions.DependencyInjection;
using Volo.Abp.Modularity;

namespace Volo.Abp.Uow;

public class AbpUnitOfWorkModule : AbpModule
{
    public override void PreConfigureServices(ServiceConfigurationContext context)
    {
        context.Services.OnRegistered(UnitOfWorkInterceptorRegistrar.RegisterIfNeeded);
    }
}
</code></pre>
<p><br><br></p>
<hr />
<h2 id="section-2">註冊流程分析</h2>
<p>在 <code>UseAutofac()</code> 執行的過程中，透過 <code>AbpRegistrationBuilderExtensions</code> 的 <code>InvokeRegistrationActions</code> 與 <code>AddInterceptors</code> 擴充方法將攔截器註冊到容器：</p>
<ul>
<li>若服務是介面，呼叫 <code>EnableInterfaceInterceptors()</code>。</li>
<li>若服務是類別，呼叫 <code>EnableClassInterceptors()</code>。</li>
<li><code>InterceptedBy</code> 註冊的攔截器為泛型類別 <code>AbpAsyncDeterminationInterceptor&lt;TInterceptor&gt;</code>，
因此最終註冊的形式為 <code>AbpAsyncDeterminationInterceptor&lt;UnitOfWorkInterceptor&gt;</code>，
負責將 <code>IAsyncInterceptor</code> 轉接成 <code>IInterceptor</code>。</li>
</ul>
<pre><code class="language-text">private static IRegistrationBuilder&lt;TLimit, TActivatorData, TRegistrationStyle&gt; InvokeRegistrationActions&lt;TLimit, TActivatorData, TRegistrationStyle&gt;(
        this IRegistrationBuilder&lt;TLimit, TActivatorData, TRegistrationStyle&gt; registrationBuilder,
        ServiceRegistrationActionList registrationActionList,
        Type serviceType,
        Type implementationType,
        object? serviceKey = null)
        where TActivatorData : ReflectionActivatorData
    {
        var serviceRegistredArgs = new OnServiceRegistredContext(serviceType, implementationType, serviceKey);

        foreach (var registrationAction in registrationActionList)
        {
            registrationAction.Invoke(serviceRegistredArgs);
        }

        if (serviceRegistredArgs.Interceptors.Any())
        {
            var disableAbpFeaturesAttribute = serviceRegistredArgs.ImplementationType.GetCustomAttribute&lt;DisableAbpFeaturesAttribute&gt;(true);
            if (disableAbpFeaturesAttribute == null || !disableAbpFeaturesAttribute.DisableInterceptors)
            {
                registrationBuilder = registrationBuilder.AddInterceptors(
                    registrationActionList,
                    serviceType,
                    serviceRegistredArgs.Interceptors
                );
            }
        }

        return registrationBuilder;
    }

private static IRegistrationBuilder&lt;TLimit, TActivatorData, TRegistrationStyle&gt;
        AddInterceptors&lt;TLimit, TActivatorData, TRegistrationStyle&gt;(
            this IRegistrationBuilder&lt;TLimit, TActivatorData, TRegistrationStyle&gt; registrationBuilder,
            ServiceRegistrationActionList serviceRegistrationActionList,
            Type serviceType,
            IEnumerable&lt;Type&gt; interceptors)
        where TActivatorData : ReflectionActivatorData
    {
        if (serviceType.IsInterface)
        {
            registrationBuilder = registrationBuilder.EnableInterfaceInterceptors();
        }
        else
        {
            if (serviceRegistrationActionList.IsClassInterceptorsDisabled ||
                serviceRegistrationActionList.DisabledClassInterceptorsSelectors.Any(selector =&gt; selector.Predicate(serviceType)))
            {
                return registrationBuilder;
            }

            (registrationBuilder as IRegistrationBuilder&lt;TLimit, ConcreteReflectionActivatorData, TRegistrationStyle&gt;)?.EnableClassInterceptors();
        }

        foreach (var interceptor in interceptors)
        {
            registrationBuilder.InterceptedBy(
                typeof(AbpAsyncDeterminationInterceptor&lt;&gt;).MakeGenericType(interceptor)
            );
        }

        return registrationBuilder;
    }
</code></pre>
<p><br><br></p>
<h3 id="section-3">轉接層</h3>
<p><code>AbpAsyncDeterminationInterceptor</code> 是 ABP 建立的抽象封裝，繼承的類別是之前提到過的 <code>AsyncDeterminationInterceptor</code> 關鍵類別，
能夠轉接成 <code>IInterceptor</code> 攔截器。</p>
<p>這裡將 <code>CastleAsyncAbpInterceptorAdapter&lt;TInterceptor&gt;</code> 將 ABP 攔截器轉接給 Castle：</p>
<pre><code class="language-text">using Castle.DynamicProxy;
using Volo.Abp.DynamicProxy;

namespace Volo.Abp.Castle.DynamicProxy;

public class AbpAsyncDeterminationInterceptor&lt;TInterceptor&gt; : AsyncDeterminationInterceptor
    where TInterceptor : IAbpInterceptor
{
    public AbpAsyncDeterminationInterceptor(TInterceptor abpInterceptor)
        : base(new CastleAsyncAbpInterceptorAdapter&lt;TInterceptor&gt;(abpInterceptor))
    {

    }
}
</code></pre>
<p><code>CastleAsyncAbpInterceptorAdapter</code> 則是繼承 <code>AsyncInterceptorBase</code> 類別，我們已經知道它的底層就是 <code>IAsyncInterceptor</code> 介面，
這個轉接層就是 Castle 攔截器呼叫 ABP Castle 攔截器的地方，也就是開始執行 <code>UnitOfWorkInterceptor</code> 的 <code>InterceptAsync</code> 方法。</p>
<pre><code class="language-text">using System;
using System.Threading.Tasks;
using Castle.DynamicProxy;
using Volo.Abp.DynamicProxy;

namespace Volo.Abp.Castle.DynamicProxy;

public class CastleAsyncAbpInterceptorAdapter&lt;TInterceptor&gt; : AsyncInterceptorBase
    where TInterceptor : IAbpInterceptor
{
    private readonly TInterceptor _abpInterceptor;

    public CastleAsyncAbpInterceptorAdapter(TInterceptor abpInterceptor)
    {
        _abpInterceptor = abpInterceptor;
    }

    protected override async Task InterceptAsync(IInvocation invocation, IInvocationProceedInfo proceedInfo, Func&lt;IInvocation, IInvocationProceedInfo, Task&gt; proceed)
    {
        await _abpInterceptor.InterceptAsync(
            new CastleAbpMethodInvocationAdapter(invocation, proceedInfo, proceed)
        );
    }

    protected override async Task&lt;TResult&gt; InterceptAsync&lt;TResult&gt;(IInvocation invocation, IInvocationProceedInfo proceedInfo, Func&lt;IInvocation, IInvocationProceedInfo, Task&lt;TResult&gt;&gt; proceed)
    {
        var adapter = new CastleAbpMethodInvocationAdapterWithReturnValue&lt;TResult&gt;(invocation, proceedInfo, proceed);

        await _abpInterceptor.InterceptAsync(
            adapter
        );

        return (TResult)adapter.ReturnValue;
    }
}
</code></pre>
<p>另外 ABP 為了避免直接依賴 Castle Core 的 <code>invocation.Proceed()</code> 方法呼叫原始流程，所以引入了 <code>IAbpMethodInvocation</code> 介面</p>
<p>透過 <code>CastleAbpMethodInvocationAdapter</code> 類別將原本 Castle Core 的資訊包裝成 ABP 專用的 <code>IAbpMethodInvocation</code> 介面</p>
<p>因此 <code>UnitOfWorkInterceptor</code> 只需要呼叫 <code>invocation.ProceedAsync()</code> 背後就會透過轉接層呼叫 Castle Core 的 <code>invocation.Proceed()</code>。</p>
<pre><code class="language-text">using System;
using System.Threading.Tasks;
using Castle.DynamicProxy;
using Volo.Abp.DynamicProxy;

namespace Volo.Abp.Castle.DynamicProxy;

public class CastleAbpMethodInvocationAdapter : CastleAbpMethodInvocationAdapterBase, IAbpMethodInvocation
{
    protected IInvocationProceedInfo ProceedInfo { get; }
    protected Func&lt;IInvocation, IInvocationProceedInfo, Task&gt; Proceed { get; }

    public CastleAbpMethodInvocationAdapter(IInvocation invocation, IInvocationProceedInfo proceedInfo,
        Func&lt;IInvocation, IInvocationProceedInfo, Task&gt; proceed)
        : base(invocation)
    {
        ProceedInfo = proceedInfo;
        Proceed = proceed;
    }

    public override async Task ProceedAsync()
    {
        await Proceed(Invocation, ProceedInfo);
    }
}
</code></pre>
<p><br><br></p>
<hr />
<h2 id="summary">Summary</h2>
<p>ABP 的 AOP 流程大致如下：</p>
<ol>
<li>當呼叫 <code>MyService.DoWorkAsync()</code> 時，由於應用程式啟動階段已透過 Autofac 將所有攔截器預先綁定到服務上，
此時實際被呼叫的物件並非 MyService 本身，而是 Castle DynamicProxy 產生的 Proxy 物件。</li>
<li>Proxy 會依序執行已註冊的攔截器，其中包含 <code>AbpAsyncDeterminationInterceptor&lt;UnitOfWorkInterceptor&gt;</code>。</li>
<li>由於 <code>AbpAsyncDeterminationInterceptor&lt;UnitOfWorkInterceptor&gt;</code> 繼承自 <code>AsyncDeterminationInterceptor</code>，
它會在內部判斷目前呼叫的 <code>MyService.DoWorkAsync()</code> 是非同步方法，並自動轉交給 <code>CastleAsyncAbpInterceptorAdapter</code> 的 <code>InterceptAsync</code> 方法處理。</li>
<li><code>CastleAsyncAbpInterceptorAdapter</code> 透過依賴注入取得 <code>UnitOfWorkInterceptor</code>，
將 Castle 的 <code>IInvocation</code>、<code>ProceedInfo</code> 資訊封裝成 ABP 專用的 <code>CastleAbpMethodInvocationAdapter</code>，
再呼叫 <code>UnitOfWorkInterceptor.InterceptAsync(CastleAbpMethodInvocationAdapter)</code>。</li>
<li><code>UnitOfWorkInterceptor.InterceptAsync</code> 先執行前置邏輯(開始事務)，
接著呼叫 <code>invocation.ProceedAsync()</code>，流程便會回到 Proxy 物件，執行真正的 <code>MyService.DoWorkAsync()</code> 方法。</li>
<li>當原始方法執行完成後，流程會再返回 <code>UnitOfWorkInterceptor.InterceptAsync</code>，執行後置邏輯(提交或回滾交易)，
最後將結果一路回傳給的呼叫端。</li>
</ol>
<pre><code class="language-text">Client
   |
   v
呼叫 MyService.DoWorkAsync()
   |
   v
IMyService 介面與攔截器在程式啟動時已經綁定好
   |
   v
AbpAsyncDeterminationInterceptor&lt;UnitOfWorkInterceptor&gt;
   |
   v
CastleAsyncAbpInterceptorAdapter&lt;UnitOfWorkInterceptor&gt;
   |
   v
UnitOfWorkInterceptor.InterceptAsync
┌──────────────────────────┐
│ 前置邏輯(開始事務)          │
│ invocation.ProceedAsync()│ -&gt; MyService.DoWorkAsync()
│ 後置邏輯(提交/回滾)         │
└──────────────────────────┘
   |
   v
結果回傳給 Client
</code></pre>


          

        </div>
      </div>
  <div id="comments-container" class="row">
    <!--<div class="likecoin-embed likecoin-button" data-liker-id="allengaodev" data-href='https://blog.allengaodev.com/posts/abp-io-interceptors'></div>
 <script src="https://static.like.co/sdk/v1/button.js"></script> -->

<script src="https://giscus.app/client.js"
        data-repo='allengaodev/allengaodev.github.io'
        data-repo-id='R_kgDOI6sF8g'
        data-category-id='DIC_kwDOI6sF8s4CUbuw'
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="light"
        data-lang="en"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
</script>

  </div>
    </div>
  </main>

  <hr>

  <!-- Footer -->
  <footer>
  <div class="container">
    <div class="row">
      <div class="col-md-12 text-center">
        <p class="copyright">&#xA9; 2025 by Allen Gao</p>

      </div>
    </div>
  </div>
</footer>


  <!-- Scripts -->
  <script async src='/vendor/bootstrap/js/bootstrap.bundle.min.js'></script>
  <script async src='/vendor/startbootstrap-clean-blog/js/scripts.js'></script>
  <script async src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
  <script async src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js" data-no-mirror></script>
  <script async src="https://cdn.jsdelivr.net/npm/quicklink@2.3.0/dist/quicklink.umd.js" onload="quicklink.listen();"></script>
  

  
</body>

</html>
