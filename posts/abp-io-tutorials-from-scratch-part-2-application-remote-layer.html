<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="preconnect" href="https://giscus.app" crossorigin>
  <link rel="preload" as="style" href='/scss/clean-blog-min.css'/>

    <meta name="description" content="ABP IO &#x8EDF;&#x9AD4;&#x6846;&#x67B6;&#x6559;&#x5B78; Part 2 - &#x5F9E;&#x982D;&#x958B;&#x59CB;&#x5EFA;&#x7ACB;&#x65B0;&#x6A21;&#x7D44; - &#x61C9;&#x7528;&#x5C64;&#x8207;&#x9060;&#x7AEF;&#x670D;&#x52D9;&#x5C64;">

  <title>ABP IO &#x8EDF;&#x9AD4;&#x6846;&#x67B6;&#x6559;&#x5B78; Part 2 - &#x5F9E;&#x982D;&#x958B;&#x59CB;&#x5EFA;&#x7ACB;&#x65B0;&#x6A21;&#x7D44; - &#x61C9;&#x7528;&#x5C64;&#x8207;&#x9060;&#x7AEF;&#x670D;&#x52D9;&#x5C64;</title>


  <link rel="canonical" href='https://blog.allengaodev.com/posts/abp-io-tutorials-from-scratch-part-2-application-remote-layer'>

      <link type="application/rss+xml" rel="alternate" title="&#x958B;&#x767C;&#x7A7A;&#x9593;" href="/feed.rss" />
      <link type="application/atom+xml" rel="alternate" title="&#x958B;&#x767C;&#x7A7A;&#x9593;" href="/feed.atom" />

  <meta name="application-name" content='Gao.Dev' />
  <meta name="msapplication-tooltip" content='Gao.Dev' />
  <meta name="msapplication-starturl" content='/' />
  <meta name="google-site-verification" content="aq71qXzppLuXZ8be8mjOwn_zJq317ZSD34yTS4i6y6M" />
  <meta property="og:title" content='ABP IO &#x8EDF;&#x9AD4;&#x6846;&#x67B6;&#x6559;&#x5B78; Part 2 - &#x5F9E;&#x982D;&#x958B;&#x59CB;&#x5EFA;&#x7ACB;&#x65B0;&#x6A21;&#x7D44; - &#x61C9;&#x7528;&#x5C64;&#x8207;&#x9060;&#x7AEF;&#x670D;&#x52D9;&#x5C64;' />
  <meta property="og:type" content="website" />
  <meta property="og:url" content='https://blog.allengaodev.com/posts/abp-io-tutorials-from-scratch-part-2-application-remote-layer' />

  <link rel="icon" href='/favicon.svg'>

  <!-- Styles for this template (also includes Bootstrap) -->
  <link href='/scss/clean-blog-min.css' rel="stylesheet">
  <script async src='/vendor/quicklink/js/quicklink.umd.js' onload="quicklink.listen();"></script>
  <script async src='/vendor/prismjs/js/prism-core.min.js'></script>
  <script async src='/vendor/prismjs/js/prism-autoloader.min.js'></script>
  <link href='/vendor/prismjs/css/prism.min.css' rel="stylesheet" media="print" onload="this.media='all'">

  <!-- Google tag (gtag.js)-->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-EBB8LGKD99"></script>
  <script> function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-EBB8LGKD99"); </script>

  


  

</head>

<body>

  <!-- Navigation -->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href='/'>Gao.Dev</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-bs-toggle="collapse" data-bs-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
      Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ms-auto">
          <li class="nav-item">
    <a class="nav-link" href="/posts">Posts</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="/tags">Tags</a>
  </li>

      </ul>
    </div>
  </div>
</nav>


  <!-- Page Header -->
  <header class="masthead no-image">
  <div class="container position-relative">
    <div class="row">
      <div class="col-md-12">
        <div class='post-heading'>
          <h1>
            <a style="color:white" href='https://blog.allengaodev.com/posts/abp-io-tutorials-from-scratch-part-2-application-remote-layer'>ABP IO &#x8EDF;&#x9AD4;&#x6846;&#x67B6;&#x6559;&#x5B78; Part 2 - &#x5F9E;&#x982D;&#x958B;&#x59CB;&#x5EFA;&#x7ACB;&#x65B0;&#x6A21;&#x7D44; - &#x61C9;&#x7528;&#x5C64;&#x8207;&#x9060;&#x7AEF;&#x670D;&#x52D9;&#x5C64;</a>
              <span class="subheading">ABP IO &#x8EDF;&#x9AD4;&#x6846;&#x67B6;&#x6559;&#x5B78; Part 2 - &#x5F9E;&#x982D;&#x958B;&#x59CB;&#x5EFA;&#x7ACB;&#x65B0;&#x6A21;&#x7D44; - &#x61C9;&#x7528;&#x5C64;&#x8207;&#x9060;&#x7AEF;&#x670D;&#x52D9;&#x5C64;</span>
          </h1>
            <div class="meta">Published on Friday, June 16, 2023</div>
              <div class="mt-3">
                  <a href="/tags/abp" class="badge text-bg-secondary"> ABP</a>
              </div>
        </div>
      </div>
    </div>
  </div>
</header>


  <!-- Main Content -->
  <div class="container">
    <div class="row">
      <div id="content" class="col-md-12">
        <h2 id="application-layer">Application Layer</h2>
<p>今天要來處理剩下的應用層與遠端服務層，這兩個層級概念跟我們常用的 MVC 的模式有點類似，背後需要建立 Controller 與
ViewModel 來處理 CRUD 的操作，不過在 DDD 戰術設計中建立了兩個概念分別為 <code>Application Services</code> 與 <code>Data Transfer Objects (DTOs)</code>。</p>
<p>在第一篇的文章中提到應用層為表現層與領域層中間的一層媒介，通常會建立一個任務來操作多個商業邏輯，以書店為例我們可以建立一個 <code>Book Application Service</code>
對書本進行增刪查改等商業邏輯，這裡 ABP 額外建立了一個層級叫做遠端服務層，這個層並不是必要的因為他的主要用途是用來定義回傳的 HTTP 請求，
這裡分開的用意是將商業邏輯全部包在應用層，MVC 的邏輯全部包遠端服務層，你也可以直接將遠端服務層刪除改寫到應用層也是同樣的道理，
<code>DTO</code> 的意思就跟 ViewModel 一樣了，都是用來降低專案之間的耦合，如果直接使用昨天建立的 Book 實體(Entity)，
雖然也是可行但以後只要修改 Entity 時會影響到表現層的邏輯。</p>
<p>所以我們目前需要的流程為建立一個 <code>Application Services</code> 與多個 <code>DTO</code> 來代表增刪查改的請求參數，並透過 <code>AutoMapper</code> 將
<code>DTO</code> 轉換成我們實際需要的 Entity 最後呼叫昨天建立的 Repository 將資料保存到資料庫內。</p>
<p>接下來我們看一下 <code>Volo.Abp.Ddd.Application</code> 與 <code>Volo.Abp.Ddd.Application.Contracts</code>，從名稱可以看出這兩個 Package 跟
昨天提到的 <code>Volo.Abp.Ddd.Domain</code> 都是屬於 ABP 定義 DDD 相關戰術設計會用到的基礎 Package。</p>
<p><code>Application Services</code> 常用的有以下幾種：</p>
<ul>
<li>ApplicationService 為基礎的 Class 以下兩種都是繼承後添加額外的功能</li>
<li>CrudAppService 會自動幫忙建立 CRUD 的方法如果需求比較簡單可以直接繼承這個 Class。</li>
<li>ReadOnlyAppService 只會自動建立讀取的方法，可以用在一些報表展示的功能上。</li>
</ul>
<p><code>DTO</code> 就有非常多種類型可以讓我們直接繼承例如以下幾個：</p>
<ul>
<li>EntityDto 為最基礎的 DTO 如果不需要其他功能可以選擇直接繼承</li>
<li>PagedResultDto 可以幫你的 DTO 添加 TotalCount 屬性讓前端能做到分頁的功能</li>
<li>AuditedEntityDto 能夠把你的 DTO 的操作紀錄到 ABP 審計系統裡面</li>
</ul>
<p>至於為什麼應用層需要額外分出一個 <code>Contracts</code> 呢？這是根據 SOLID 的 DIP 依賴反轉原則所建立出的一個抽象層，
我們需要將抽象的界面定義在 <code>Contracts</code> 讓高階模組依賴這個應用層合約來避免未來低階模組變動時對高階模組產生影響。</p>
<p>了解過後我們先把 CRUD 的 DTO 建立出來， 前往 <code>BookStoreScratch.Application.Contracts</code> 建立一個新的資料夾 <code>Books</code></p>
<pre><code class="language-text">// BookDto.cs

using System;
using Volo.Abp.Application.Dtos;

namespace BookStoreScratch.Books;

public class BookDto : AuditedEntityDto&lt;Guid&gt;
{
    public string Name { get; set; }

    public BookType Type { get; set; }

    public DateTime PublishDate { get; set; }

    public float Price { get; set; }
}
</code></pre>
<pre><code class="language-text">CreateUpdateBookDto.cs
using System;
using System.ComponentModel.DataAnnotations;

namespace BookStoreScratch.Books;

public class CreateUpdateBookDto
{
    [Required]
    [StringLength(128)]
    public string Name { get; set; }

    [Required]
    public BookType Type { get; set; } = BookType.Undefined;

    [Required]
    [DataType(DataType.Date)]
    public DateTime PublishDate { get; set; } = DateTime.Now;

    [Required]
    public float Price { get; set; }
}
</code></pre>
<p>這裡建立一個界面 <code>IBookAppService</code> 並繼承 ICrudAppService 界面，依序帶入需要的 DTO 與Entity 主鍵</p>
<pre><code class="language-text">// IBookAppService.cs

using System;
using BookStoreScratch.Books;
using Volo.Abp.Application.Dtos;
using Volo.Abp.Application.Services;

namespace BookStoreScratch;

public interface IBookAppService
    : ICrudAppService&lt;
        BookDto,
        Guid,
        PagedAndSortedResultRequestDto,
        CreateUpdateBookDto&gt;
{
}
</code></pre>
<p>完成後到 <code>BookStoreScratch.Application</code> 建立資料夾 <code>Books</code> 並實做 <code>IBookAppService</code>，這裡繼承 <code>CrudAppService</code>
主要是為了要它內部預設的 CRUD 方法。</p>
<pre><code class="language-text">// BookAppService.cs

using System;
using Volo.Abp.Application.Dtos;
using Volo.Abp.Application.Services;
using Volo.Abp.Domain.Repositories;

namespace BookStoreScratch.Books;

public class BookAppService : 
    CrudAppService&lt;
        Book,
        BookDto,
        Guid,
        PagedAndSortedResultRequestDto,
        CreateUpdateBookDto&gt;,
    IBookAppService
{
    public BookAppService(IRepository&lt;Book, Guid&gt; repository) : base(repository)
    {
    }
}
</code></pre>
<p>我們順便看一下 <code>CrudAppService</code> 的原始碼，可以看到並沒有使用特別的設計就是從 DI 取得 Repository 後直接呼叫內部的方法來操作資料，
因此你也可以直接實做 <code>IBookAppService</code> 需要的方法也可以達到同樣的效果。</p>
<details> 
   <summary>CrudAppService & AbstractKeyCrudAppService Detail</summary>
<pre><code class="language-text">public abstract class CrudAppService&lt;TEntity, TGetOutputDto, TGetListOutputDto, TKey, TGetListInput, TCreateInput, TUpdateInput&gt;
    : AbstractKeyCrudAppService&lt;TEntity, TGetOutputDto, TGetListOutputDto, TKey, TGetListInput, TCreateInput, TUpdateInput&gt;
    where TEntity : class, IEntity&lt;TKey&gt;
    where TGetOutputDto : IEntityDto&lt;TKey&gt;
    where TGetListOutputDto : IEntityDto&lt;TKey&gt;
{
    protected new IRepository&lt;TEntity, TKey&gt; Repository { get; }

    protected CrudAppService(IRepository&lt;TEntity, TKey&gt; repository)
        : base(repository)
    {
        Repository = repository;
    }

    protected override async Task DeleteByIdAsync(TKey id)
    {
        await Repository.DeleteAsync(id);
    }

    protected override async Task&lt;TEntity&gt; GetEntityByIdAsync(TKey id)
    {
        return await Repository.GetAsync(id);
    }

    protected override void MapToEntity(TUpdateInput updateInput, TEntity entity)
    {
        if (updateInput is IEntityDto&lt;TKey&gt; entityDto)
        {
            entityDto.Id = entity.Id;
        }

        base.MapToEntity(updateInput, entity);
    }

    protected override IQueryable&lt;TEntity&gt; ApplyDefaultSorting(IQueryable&lt;TEntity&gt; query)
    {
        if (typeof(TEntity).IsAssignableTo&lt;IHasCreationTime&gt;())
        {
            return query.OrderByDescending(e =&gt; ((IHasCreationTime)e).CreationTime);
        }
        else
        {
            return query.OrderByDescending(e =&gt; e.Id);
        }
    }
}
</code></pre>
<pre><code class="language-text">public abstract class AbstractKeyCrudAppService&lt;TEntity, TGetOutputDto, TGetListOutputDto, TKey, TGetListInput, TCreateInput, TUpdateInput&gt;
    : AbstractKeyReadOnlyAppService&lt;TEntity, TGetOutputDto, TGetListOutputDto, TKey, TGetListInput&gt;,
        ICrudAppService&lt;TGetOutputDto, TGetListOutputDto, TKey, TGetListInput, TCreateInput, TUpdateInput&gt;
    where TEntity : class, IEntity
{
    protected IRepository&lt;TEntity&gt; Repository { get; }

    protected virtual string CreatePolicyName { get; set; }

    protected virtual string UpdatePolicyName { get; set; }

    protected virtual string DeletePolicyName { get; set; }

    protected AbstractKeyCrudAppService(IRepository&lt;TEntity&gt; repository)
        : base(repository)
    {
        Repository = repository;
    }

    public virtual async Task&lt;TGetOutputDto&gt; CreateAsync(TCreateInput input)
    {
        await CheckCreatePolicyAsync();

        var entity = await MapToEntityAsync(input);

        TryToSetTenantId(entity);

        await Repository.InsertAsync(entity, autoSave: true);

        return await MapToGetOutputDtoAsync(entity);
    }

    public virtual async Task&lt;TGetOutputDto&gt; UpdateAsync(TKey id, TUpdateInput input)
    {
        await CheckUpdatePolicyAsync();

        var entity = await GetEntityByIdAsync(id);
        //TODO: Check if input has id different than given id and normalize if it's default value, throw ex otherwise
        await MapToEntityAsync(input, entity);
        await Repository.UpdateAsync(entity, autoSave: true);

        return await MapToGetOutputDtoAsync(entity);
    }

    public virtual async Task DeleteAsync(TKey id)
    {
        await CheckDeletePolicyAsync();

        await DeleteByIdAsync(id);
    }

    protected abstract Task DeleteByIdAsync(TKey id);

    protected virtual async Task CheckCreatePolicyAsync()
    {
        await CheckPolicyAsync(CreatePolicyName);
    }

    protected virtual async Task CheckUpdatePolicyAsync()
    {
        await CheckPolicyAsync(UpdatePolicyName);
    }

    protected virtual async Task CheckDeletePolicyAsync()
    {
        await CheckPolicyAsync(DeletePolicyName);
    }

    /// &lt;summary&gt;
    /// Maps &lt;typeparamref name=&quot;TCreateInput&quot;/&gt; to &lt;typeparamref name=&quot;TEntity&quot;/&gt; to create a new entity.
    /// It uses &lt;see cref=&quot;MapToEntity(TCreateInput)&quot;/&gt; by default.
    /// It can be overriden for custom mapping.
    /// Overriding this has higher priority than overriding the &lt;see cref=&quot;MapToEntity(TCreateInput)&quot;/&gt;
    /// &lt;/summary&gt;
    protected virtual Task&lt;TEntity&gt; MapToEntityAsync(TCreateInput createInput)
    {
        return Task.FromResult(MapToEntity(createInput));
    }

    /// &lt;summary&gt;
    /// Maps &lt;typeparamref name=&quot;TCreateInput&quot;/&gt; to &lt;typeparamref name=&quot;TEntity&quot;/&gt; to create a new entity.
    /// It uses &lt;see cref=&quot;IObjectMapper&quot;/&gt; by default.
    /// It can be overriden for custom mapping.
    /// &lt;/summary&gt;
    protected virtual TEntity MapToEntity(TCreateInput createInput)
    {
        var entity = ObjectMapper.Map&lt;TCreateInput, TEntity&gt;(createInput);
        SetIdForGuids(entity);
        return entity;
    }

    /// &lt;summary&gt;
    /// Sets Id value for the entity if &lt;typeparamref name=&quot;TKey&quot;/&gt; is &lt;see cref=&quot;Guid&quot;/&gt;.
    /// It's used while creating a new entity.
    /// &lt;/summary&gt;
    protected virtual void SetIdForGuids(TEntity entity)
    {
        if (entity is IEntity&lt;Guid&gt; entityWithGuidId &amp;&amp; entityWithGuidId.Id == Guid.Empty)
        {
            EntityHelper.TrySetId(
                entityWithGuidId,
                () =&gt; GuidGenerator.Create(),
                true
            );
        }
    }

    /// &lt;summary&gt;
    /// Maps &lt;typeparamref name=&quot;TUpdateInput&quot;/&gt; to &lt;typeparamref name=&quot;TEntity&quot;/&gt; to update the entity.
    /// It uses &lt;see cref=&quot;MapToEntity(TUpdateInput, TEntity)&quot;/&gt; by default.
    /// It can be overriden for custom mapping.
    /// Overriding this has higher priority than overriding the &lt;see cref=&quot;MapToEntity(TUpdateInput, TEntity)&quot;/&gt;
    /// &lt;/summary&gt;
    protected virtual Task MapToEntityAsync(TUpdateInput updateInput, TEntity entity)
    {
        MapToEntity(updateInput, entity);
        return Task.CompletedTask;
    }

    /// &lt;summary&gt;
    /// Maps &lt;typeparamref name=&quot;TUpdateInput&quot;/&gt; to &lt;typeparamref name=&quot;TEntity&quot;/&gt; to update the entity.
    /// It uses &lt;see cref=&quot;IObjectMapper&quot;/&gt; by default.
    /// It can be overriden for custom mapping.
    /// &lt;/summary&gt;
    protected virtual void MapToEntity(TUpdateInput updateInput, TEntity entity)
    {
        ObjectMapper.Map(updateInput, entity);
    }

    protected virtual void TryToSetTenantId(TEntity entity)
    {
        if (entity is IMultiTenant &amp;&amp; HasTenantIdProperty(entity))
        {
            var tenantId = CurrentTenant.Id;

            if (!tenantId.HasValue)
            {
                return;
            }

            var propertyInfo = entity.GetType().GetProperty(nameof(IMultiTenant.TenantId));

            if (propertyInfo == null || propertyInfo.GetSetMethod(true) == null)
            {
                return;
            }

            propertyInfo.SetValue(entity, tenantId);
        }
    }

    protected virtual bool HasTenantIdProperty(TEntity entity)
    {
        return entity.GetType().GetProperty(nameof(IMultiTenant.TenantId)) != null;
    }
}
</code></pre>
</details> 
<p>我們擷取一段 Create 方法來看看內部做了什麼事情</p>
<pre><code class="language-text">// AbstractKeyCrudAppService.cs

public virtual async Task&lt;TGetOutputDto&gt; CreateAsync(TCreateInput input)
{
    await CheckCreatePolicyAsync();

    var entity = await MapToEntityAsync(input);

    TryToSetTenantId(entity);

    await Repository.InsertAsync(entity, autoSave: true);

    return await MapToGetOutputDtoAsync(entity);
}

protected virtual TEntity MapToEntity(TCreateInput createInput)
{
    var entity = ObjectMapper.Map&lt;TCreateInput, TEntity&gt;(createInput);
    SetIdForGuids(entity);
    return entity;
}

protected virtual void SetIdForGuids(TEntity entity)
{
    if (entity is IEntity&lt;Guid&gt; entityWithGuidId &amp;&amp; entityWithGuidId.Id == Guid.Empty)
    {
        EntityHelper.TrySetId(
            entityWithGuidId,
            () =&gt; GuidGenerator.Create(),
            true
        );
    }
}
</code></pre>
<pre><code class="language-text">// EfCoreRepository.cs

public override async Task&lt;TEntity&gt; InsertAsync(TEntity entity, bool autoSave = false, CancellationToken cancellationToken = default)
{
    CheckAndSetId(entity);

    var dbContext = await GetDbContextAsync();

    var savedEntity = (await dbContext.Set&lt;TEntity&gt;().AddAsync(entity, GetCancellationToken(cancellationToken))).Entity;

    if (autoSave)
    {
        await dbContext.SaveChangesAsync(GetCancellationToken(cancellationToken));
    }

    return savedEntity;
}
</code></pre>
<p>可以整理出以下幾個關鍵步驟:</p>
<ol>
<li>CheckCreatePolicyAsync: 會檢查使用者是否有權限呼叫新增功能，要搭配 ABP 的權限系統。</li>
<li>MapToEntityAsync: 內部需要搭配 AutoMapper 來將傳入的 DTO 轉換成真正需要的 Entity，並且會幫忙檢查 Entity 使否有帶入主鍵沒有的話會自動建立。</li>
<li>TryToSetTenantId: 自動設定 Entity 的租戶 ID，要搭配 ABP 的租戶系統。</li>
<li>Repository.InsertAsync: 呼叫 Repository 的 Insert 方法，會使用到上篇文章建立的 <code>BookRepository</code>。</li>
<li>MapToGetOutputDtoAsync: 將建立完成的 Entity 再次透過 AutoMapper 轉換成顯示專用的 DTO。</li>
</ol>
<p>首先 ABP 的權限系統與租戶系統是可選的，如果你沒有需要使用的話內部也會自行跳過，所以最關鍵的就是物件映射這一塊也就是 AutoMapper 提供的功能，
換句話說要使用 <code>CrudAppService</code> 就必須要搭配 AutoMapper 否則會沒辦法運行。</p>
<p>所以我們先到 <code>BookStoreScratch.Application</code> 安裝 <code>Volo.Abp.AutoMapper</code> 並建立 Profile。</p>
<pre><code class="language-text">dotnet add package Volo.Abp.AutoMapper --version 7.2.2
</code></pre>
<pre><code class="language-text">// BookStoreScratchApplicationAutoMapperProfile.cs

using AutoMapper;
using BookStoreScratch.Books;

namespace BookStoreScratch;

public class BookStoreScratchApplicationAutoMapperProfile : Profile
{
    public BookStoreScratchApplicationAutoMapperProfile()
    {
        CreateMap&lt;Book, BookDto&gt;();
        CreateMap&lt;CreateUpdateBookDto, Book&gt;();
    }
}
</code></pre>
<p>安裝後將 <code>AbpAutoMapperModule</code> 註冊到我們的 <code>BookStoreScratchApplicationModule</code> 並使用 AddMaps 方法將我們的 Profile 註冊到系統內。</p>
<pre><code class="language-text">using Microsoft.Extensions.DependencyInjection;
using Volo.Abp.Application;
using Volo.Abp.AutoMapper;
using Volo.Abp.Modularity;

namespace BookStoreScratch;

[DependsOn(
    typeof(AbpDddApplicationModule),
    typeof(AbpAutoMapperModule)
)]
[DependsOn(
    typeof(BookStoreScratchApplicationContractsModule),
    typeof(BookStoreScratchDomainModule)
)]
public class BookStoreScratchApplicationModule : AbpModule
{
    public override void ConfigureServices(ServiceConfigurationContext context)
    {
        context.Services.AddAutoMapperObjectMapper&lt;BookStoreScratchApplicationModule&gt;();
        Configure&lt;AbpAutoMapperOptions&gt;(options =&gt;
        {
            options.AddMaps&lt;BookStoreScratchApplicationModule&gt;();
        });
    }
}
</code></pre>
<hr />
<h2 id="httpapi-layer">HttpApi Layer</h2>
<p>應用層準備完成後最後是遠端服務層，我們之前在準備專案時有幫這個專案安裝了一個 <code>Volo.Abp.AspNetCore.Mvc</code> 與參考 <code>BookStoreScratch.Application.Contracts</code>
專案，這個專案的主要目的是建立一個額外的 Controller 層級來處理 HTTP 相關的回應。</p>
<p>我們知道在 Dotnet 中建立 Controller 時需要繼承 ControllerBase，在 ABP 中則是提供了 AbpControllerBase 給我們使用，
底層其實也是繼承了 ControllerBase 不過額外添加了許多 ABP 建立的功能。</p>
<p>接下來前往 <code>BookStoreScratch.HttpApi</code> 建立一個 <code>Controllers</code> 資料夾並新增一個 <code>BookController</code> 並實做 <code>IBookAppService</code> 界面，
這段程式主要就是在定義 HTTP Method 與 API Route，定義完成後透過依賴注入取得 BookAppService 並直接把請求轉送給它，因為大部分的功能都是 CRUD
的操作而已，所以這種轉送的工作其實也可以交由 ABP 幫忙自動產生詳細的流程會在設定 Host 專案時提到。</p>
<pre><code class="language-text">// BookController.cs

using System;
using System.Threading.Tasks;
using BookStoreScratch.Books;
using Microsoft.AspNetCore.Mvc;
using Volo.Abp;
using Volo.Abp.Application.Dtos;
using Volo.Abp.AspNetCore.Mvc;

namespace BookStoreScratch.Controllers;

[Area(&quot;book&quot;)]
[RemoteService(Name = &quot;book&quot;)]
[Route(&quot;api/book&quot;)]
public class BookController : AbpControllerBase, IBookAppService
{
    private readonly IBookAppService _bookAppService;

    public BookController(IBookAppService bookAppService)
    {
        _bookAppService = bookAppService;
    }

    [HttpGet(&quot;{id}&quot;)]
    public async Task&lt;BookDto&gt; GetAsync(Guid id)
    {
        return await _bookAppService.GetAsync(id);
    }

    [HttpGet]
    public async Task&lt;PagedResultDto&lt;BookDto&gt;&gt; GetListAsync(PagedAndSortedResultRequestDto input)
    {
        return await _bookAppService.GetListAsync(input);
    }

    [HttpPost]
    public async Task&lt;BookDto&gt; CreateAsync(CreateUpdateBookDto input)
    {
        return await _bookAppService.CreateAsync(input);
    }

    [HttpPut(&quot;{id}&quot;)]
    public async Task&lt;BookDto&gt; UpdateAsync(Guid id, CreateUpdateBookDto input)
    {
        return await _bookAppService.UpdateAsync(id, input);
    }

    [HttpDelete(&quot;{id}&quot;)]
    public async Task DeleteAsync(Guid id)
    {
        await _bookAppService.DeleteAsync(id);
    }
}
</code></pre>
<hr />
<h2 id="summary">Summary</h2>
<p>今天將應用層與遠端服務層處理完成，基底差不多都已經完成了接下來就準備進入實際運作的部份，也就是 Host 專案。
我們將透過這個專案將把我們寫的模組實際運作起來並且搭配 Swagger 變成一個可以實際操作的工具，也可以試試看將我們的模組
上傳到 Nuget 上面方便之後的專案可以直接引用。</p>
<p>今天的進度 <a href="https://github.com/allengaodev/BookStoreScratch/tree/1.1" target="_blank">Github</a></p>


        

      </div>
    </div>
  <div id="comments-container" class="row">
    <!--<div class="likecoin-embed likecoin-button" data-liker-id="allengaodev" data-href='https://blog.allengaodev.com/posts/abp-io-tutorials-from-scratch-part-2-application-remote-layer'></div>
 <script src="https://static.like.co/sdk/v1/button.js"></script> -->

<script src="https://giscus.app/client.js"
        data-repo='allengaodev/allengaodev.github.io'
        data-repo-id='R_kgDOI6sF8g'
        data-category-id='DIC_kwDOI6sF8s4CUbuw'
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="light"
        data-lang="en"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
</script>

  </div>
  </div>

  <hr>

  <!-- Footer -->
  <footer>
  <div class="container">
    <div class="row">
      <div class="col-md-12 text-center">
          <p class="text-center small text-muted">Originally published at <a href='https://blog.allengaodev.com'> blog.allengaodev.com</a>.</p>
          <br />
        <p class="copyright">&#xA9; Allen Gao 2024</p>

      </div>
    </div>
  </div>
</footer>


  <!-- Scripts -->
  <script async src='/vendor/bootstrap/js/bootstrap.bundle.min1.js'></script>
  <script async src='/vendor/startbootstrap-clean-blog/js/scripts.js'></script>
  

  

</body>

</html>
