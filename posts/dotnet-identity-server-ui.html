<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="preload" as="style" href='/scss/clean-blog-min.css'/>

    <meta name="description" content="2.&#x81EA;&#x8A02;.NET Core Identity&#x8EAB;&#x4EFD;&#x9A57;&#x8B49;&#x548C;&#x6388;&#x6B0A;&#x6559;&#x5B78;&#xFF1A;Identity Server UI">

  <title>&#x81EA;&#x8A02;.NET Core Identity&#x8EAB;&#x4EFD;&#x9A57;&#x8B49;&#x548C;&#x6388;&#x6B0A;&#x6559;&#x5B78;&#xFF1A;Identity Server UI</title>


  <link rel="canonical" href='https://blog.allengaodev.com/posts/dotnet-identity-server-ui'>

      <link type="application/rss+xml" rel="alternate" title="&#x958B;&#x767C;&#x7A7A;&#x9593;" href="/feed.rss" />
      <link type="application/atom+xml" rel="alternate" title="&#x958B;&#x767C;&#x7A7A;&#x9593;" href="/feed.atom" />

  <meta name="application-name" content='Gao.Dev' />
  <meta name="msapplication-tooltip" content='Gao.Dev' />
  <meta name="msapplication-starturl" content='/' />
  <meta name="google-site-verification" content="aq71qXzppLuXZ8be8mjOwn_zJq317ZSD34yTS4i6y6M" />
  <meta property="og:title" content='&#x81EA;&#x8A02;.NET Core Identity&#x8EAB;&#x4EFD;&#x9A57;&#x8B49;&#x548C;&#x6388;&#x6B0A;&#x6559;&#x5B78;&#xFF1A;Identity Server UI' />
  <meta property="og:type" content="website" />
  <meta property="og:url" content='https://blog.allengaodev.com/posts/dotnet-identity-server-ui' />

  <link rel="icon" href='/favicon.svg'>

  <!-- Styles for this template (also includes Bootstrap) -->
  <link href='/scss/clean-blog-min.css' rel="stylesheet">

  


  

</head>

<body>

  <!-- Navigation -->
  <nav class="navbar navbar-expand navbar-light" id="mainNav" style="background-color: #F5F1E6">
  <div class="container">
    <a class="navbar-brand text-dark" href='/'> Home </a>

    <div class="navbar-nav-container" id="navbarResponsive">
      <ul class="navbar-nav ms-auto">
          <li class="nav-item">
    <a class="nav-link text-dark" href="/search">Search</a>
  </li>
  <li class="nav-item">
    <a class="nav-link text-dark" href="/posts">Posts</a>
  </li>
  <li class="nav-item">
    <a class="nav-link text-dark" href="/tags">Tags</a>
  </li>

      </ul>
    </div>
  </div>
</nav>


  <!-- Page Header -->
  <header class="masthead no-image">
  <div class="container position-relative">
    <div class="row">
      <div class="col-md-12">
        <div class='post-heading'>
          <h1>
            <a style="color:white" href='https://blog.allengaodev.com/posts/dotnet-identity-server-ui'>&#x81EA;&#x8A02;.NET Core Identity&#x8EAB;&#x4EFD;&#x9A57;&#x8B49;&#x548C;&#x6388;&#x6B0A;&#x6559;&#x5B78;&#xFF1A;Identity Server UI</a>
          </h1>
            <p class="post-meta">
              <a style="line-height: 1.8em;padding-left: 1.6em;background-size: auto 100%;background-repeat: no-repeat; background-image:url(/calendar.svg)">
                2023/05/05
              </a>

                <a style="line-height: 1.8em;padding-left: 1.6em;background-size: auto 100%;background-repeat: no-repeat; background-image:url(/overtime.svg)">
                  2026/01/20
                </a>
            </p>
              <div class="mt-3">
                  <a href="/tags/dotnet" class="badge bg-white text-dark"> Dotnet</a>
                  <a href="/tags/csharp" class="badge bg-white text-dark"> CSharp</a>
                  <a href="/tags/identity" class="badge bg-white text-dark"> Identity</a>
              </div>
        </div>
      </div>
    </div>
  </div>
</header>


  <!-- Main Content -->
  <main id="main-content">
    <div class="container">
      <div class="row">
        <div id="content" class="col-md-12">
          <h2 id="identity-server-ui">Identity Server UI</h2>
<p>在上一篇的<a href="https://blog.allengaodev.com/posts/dotnet-identity-server" target="_blank">文章</a>中
我們架設了一台自己的授權伺服器，由於目前使用的是 <code>ClientCredentials</code> 模式所以並不需要外部用戶的參與。</p>
<p>但在更常用的 <code>AuthorizationCode</code> 模式中就需要資源的擁有者同意應用程式獲取私人資訊，
就例如使用 Google 登入時會把我們瀏覽器轉跳到 Google 並且跳出權限頁面要求我們的同意。</p>
<p>很明顯目前我們的 Identity Server 沒有任何的頁面，這部分可以自己處理客製化頁面也可以直接安裝模板提供的 UI 頁面，
今天就測試把 UI 模板添加進來專案中。</p>
<p>首先回到 IdentityServer 專案並且運行命令，背後只會添加預設的 Razor 頁面以及 css、js，並不會建立一個獨立專案。</p>
<pre><code class="language-text">cd .\src\IdentityServer\
dotnet new duende-is-ui
</code></pre>
<p>注意添加完 UI 後還要設定 Middleware 否則不會生效，
接下來開啟 <code>HostingExtensions.cs</code> 檔案會發現有幾個之前就存在的註釋，
這裡 IdentityServer 已經預留好了所以我們這邊只需要將註釋解除即可。</p>
<pre><code class="language-text">// uncomment if you want to add a UI
builder.Services.AddRazorPages();

// uncomment if you want to add a UI
app.UseStaticFiles();
app.UseRouting();

// uncomment if you want to add a UI
app.UseAuthorization();
app.MapRazorPages().RequireAuthorization();
</code></pre>
<p><code>MapRazorPages().RequireAuthorization()</code> 代表所有 Razor 頁面都需要權限，因此只有 <code>AllowAnonymous</code> 屬性的頁面才可以訪問。</p>
<p>完成後運行 IdentityServer 專案就會發現首頁被替換成預設的歡迎頁面了。</p>
<hr />
<h2 id="scope-claim">Scope 與 Claim</h2>
<p>由於 <code>AuthorizationCode</code> 模式是資源擁有者將自己的資料授權給第三方應用程式讀取，
所以現在要想辦法開放第三方應用程式能夠跟 IdentityServer 申請我們的個人資料相關的功能，
為了資料安全所以申請個人資料預設沒有開啟，所以需要我們手動設定。</p>
<p>根據文檔 <a href="https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims" target="_blank">5.4.Requesting Claims using Scope Values</a>
得知跟個人資料相關的 scope 值有五個分別為:</p>
<ul>
<li>OpenId</li>
<li>Profile</li>
<li>Address</li>
<li>Email</li>
<li>Phone</li>
</ul>
<p>這裡的 scope 是代表一個資料申請範圍，例如申請 Profile 那麼就會在回傳的 JWT 中添加 <code>name</code>、<code>family_name</code>、<code>birthdate</code> 等資料，
申請 email 就會添加 <code>email</code>、<code>email_verified</code> 資料。</p>
<p>在 OpenId 這些個人資料被叫做 Claims，可以想像成身份證中欄位，我們會在定義會員時再次看到這些資訊。</p>
<p>回到 <code>Config.cs</code> 在 IdentityResources 添加所有 IdentityResource。</p>
<pre><code class="language-text">public static IEnumerable&lt;IdentityResource&gt; IdentityResources =&gt;
    new IdentityResource[]
    {
        new IdentityResources.OpenId(),
        new IdentityResources.Profile(),
        new IdentityResources.Email(),
        new IdentityResources.Phone(),
        new IdentityResources.Address()
    };
</code></pre>
<p>接下來運行專案可以在 <code>/.well-known/openid-configuration</code> 中看到 <code>scopes_supported</code> 添加了額外的 Scope，
最下方的 <code>offline_access</code> 是預設直接添加進來的，還有看到上一篇文章設定的 <code>api1</code> Scope。</p>
<pre><code class="language-text">&quot;scopes_supported&quot;: [
    &quot;openid&quot;,
    &quot;profile&quot;,
    &quot;email&quot;,
    &quot;phone&quot;,
    &quot;address&quot;,
    &quot;api1&quot;,
    &quot;offline_access&quot;
]
</code></pre>
<p>要注意 IdentityResources 代表的是 Identity Scope 主要是用來顯示個人相關資訊，回傳的資訊會保存在 ID Token 中，
我們的 <code>api1</code> 是 API Scope 主要是用來辨識存取權限，這部分的資訊會保存在 Access Token 中。</p>
<p>這也是為什麼上一篇的文章我們可以使用 <code>api1</code> Scope，
IdentityServer 會給我們一個 Access Token 內部說明我們有權使用 <code>api1</code>，
最後 API 專案透過 JWT Package 驗證帶入的 Access Token 證實我們確實擁有使用 <code>api1</code> 的權限。</p>
<p>了解背後原理後我們開啟 <code>TestUsers.cs</code> 在這個檔案中有定義兩個會員 <code>alice</code> 和 <code>bob</code>，
這裡是直接在記憶體中添加的會員，這裡的會員就是跟 Google 帳號一樣的意思。</p>
<pre><code class="language-text">new TestUser
{
    SubjectId = &quot;1&quot;,
    Username = &quot;alice&quot;,
    Password = &quot;alice&quot;,
    Claims =
    {
        new Claim(JwtClaimTypes.Name, &quot;Alice Smith&quot;),
        new Claim(JwtClaimTypes.GivenName, &quot;Alice&quot;),
        new Claim(JwtClaimTypes.FamilyName, &quot;Smith&quot;),
        new Claim(JwtClaimTypes.Email, &quot;AliceSmith&#64;email.com&quot;),
        new Claim(JwtClaimTypes.EmailVerified, &quot;true&quot;, ClaimValueTypes.Boolean),
        new Claim(JwtClaimTypes.WebSite, &quot;http://alice.com&quot;),
        new Claim(JwtClaimTypes.Address, JsonSerializer.Serialize(address), IdentityServerConstants.ClaimValueTypes.Json)
    }
},
</code></pre>
<p>開啟 <code>HostingExtensions.cs</code> 呼叫 <code>AddTestUsers</code> 將剛剛定義的會員添加到系統內</p>
<pre><code class="language-text">builder.Services.AddIdentityServer(options =&gt;
    {
        // https://docs.duendesoftware.com/identityserver/v6/fundamentals/resources/api_scopes#authorization-based-on-scopes
        options.EmitStaticAudienceClaim = true;
    })
    .AddInMemoryIdentityResources(Config.IdentityResources)
    .AddInMemoryApiScopes(Config.ApiScopes)
    .AddInMemoryClients(Config.Clients)
    .AddTestUsers(TestUsers.Users);
</code></pre>
<p>此時我們將專案運行起來並點擊 <code>Click here to see the claims for your current session.</code>
由於目前還沒有登入並且每個 Razor Page 都需要權限所以會直接轉跳到登入頁面，此時我們可以使用剛剛建立的會員來登入(帳號:alice/密碼:alice)</p>
<p>接下來到 <code>Config.cs</code> 設定一個新的 Client，並使用 <code>AuthorizationCode</code> 模式，
這裡先預設跳轉回 Port <code>5002</code>，等等建立的新專案要使用這個 Port，
並且允許這個 Client 申請 <code>OpenId</code>、<code>Profile</code>。</p>
<pre><code class="language-text">new Client
{
    ClientId = &quot;web&quot;,
    ClientSecrets = { new Secret(&quot;secret&quot;.Sha256()) },

    AllowedGrantTypes = GrantTypes.Code,
    RequireConsent = true,

    RedirectUris = { &quot;https://localhost:5002/signin-oidc&quot; },

    PostLogoutRedirectUris = { &quot;https://localhost:5002/signout-callback-oidc&quot; },

    AllowedScopes = new List&lt;string&gt;
    {
        IdentityServerConstants.StandardScopes.OpenId,
        IdentityServerConstants.StandardScopes.Profile
    }
}
</code></pre>
<p>注意之前只是開啟 IdentityServer 的全局 Scope 設定，這裡需要在 Client 設定允許的 Scope 清單。</p>
<hr />
<p>現在我們添加一個 Razor 專案來模擬前端請求頁面，通常這裡會搭配登入頁面與外部登入按鈕清單。</p>
<pre><code class="language-text">dotnet new webapp -n WebClient
cd ..
dotnet sln add ./src/WebClient/WebClient.csproj
</code></pre>
<p>WebClient 專案新增 OpenIdConnect Package</p>
<pre><code class="language-text">dotnet add package Microsoft.AspNetCore.Authentication.OpenIdConnect
</code></pre>
<p>接下來在 <code>Program.cs</code> 添加 Cookie 與 OpenId 這部份可以參考以前的文章有詳細討論過</p>
<ul>
<li><a href="https://blog.allengaodev.com/posts/dotnet-identity-oauth-oidc" target="_blank">oidc</a></li>
<li><a href="https://blog.allengaodev.com/posts/dotnet-identity-user-logins" target="_blank">user-logins</a></li>
</ul>
<p>注意目前並沒有整合 .NET Identity 所以並不需要 IdentityConstants.ExternalScheme 保存三方登入結果，
這裡指定 <code>DefaultChallengeScheme</code> 直接指定使用自己定義的 <code>IdentityServerOidc</code> 這樣只要一發起 Challenge
就會連線到自己的 IdentityServer。</p>
<pre><code class="language-text">JwtSecurityTokenHandler.DefaultMapInboundClaims = false;

builder.Services.AddAuthentication(options =&gt;
    {
        options.DefaultScheme = IdentityConstants.ApplicationScheme;
        options.DefaultChallengeScheme = &quot;IdentityServerOidc&quot;;
    })
    .AddCookie(IdentityConstants.ApplicationScheme)
    .AddOpenIdConnect(&quot;IdentityServerOidc&quot;, options =&gt;
    {
        options.Authority = &quot;https://localhost:5001&quot;;

        options.ClientId = &quot;web&quot;;
        options.ClientSecret = &quot;secret&quot;;
        options.ResponseType = &quot;code&quot;;

        options.Scope.Clear();
        options.Scope.Add(&quot;openid&quot;);
        options.Scope.Add(&quot;profile&quot;);
        options.GetClaimsFromUserInfoEndpoint = true;

        options.SaveTokens = true;
    });
</code></pre>
<pre><code class="language-text">app.UseAuthentication();
app.UseAuthorization();
app.MapRazorPages().RequireAuthorization();
</code></pre>
<p>我們強制要求所有頁面要有權限才能觀看，因此現在打開任何一個頁面會先檢查瀏覽器 Cookie DefaultScheme 看看存不存在，
發現沒有登入 cookie 時會自動發起 Challenge 將我們的頁面轉跳到 IdentityServer。</p>
<p>修改 <code>Pages/Index.cshtml</code> 的內容，會去讀取目前登入的會員並且列出所有的 Claim</p>
<pre><code class="language-text">&#64;page
&#64;model IndexModel
&#64;using Microsoft.AspNetCore.Authentication

&#64;{
    var result = await HttpContext.AuthenticateAsync();
}

&#64;if (!result.Succeeded)
{
    &lt;h2&gt;Welcome (Guest)&lt;/h2&gt;
    &lt;form method=&quot;post&quot; asp-page-handler=&quot;Login&quot;&gt;
        &lt;button class=&quot;btn btn-primary btn-lg&quot;&gt;使用 IdentityServer 登入&lt;/button&gt;
    &lt;/form&gt;
}
else
{
    &lt;h2&gt;Claims&lt;/h2&gt;
    &lt;dl&gt;
        &#64;foreach (var claim in User.Claims)
        {
            &lt;dt&gt;&#64;claim.Type&lt;/dt&gt;
            &lt;dd&gt;&#64;claim.Value&lt;/dd&gt;
        }
    &lt;/dl&gt;

    &lt;h2&gt;Properties&lt;/h2&gt;
    &lt;dl&gt;
        &#64;if (result.Properties?.Items != null)
        {
            foreach (var prop in result.Properties.Items)
            {
                &lt;dt&gt;&#64;prop.Key&lt;/dt&gt;
                &lt;dd&gt;&#64;prop.Value&lt;/dd&gt;
            }
        }
    &lt;/dl&gt;
}
</code></pre>
<pre><code class="language-text">using Microsoft.AspNetCore.Authentication;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.RazorPages;

namespace WebClient.Pages;

[AllowAnonymous]
public class IndexModel : PageModel
{
    public void OnGet()
    {

    }

    public IActionResult OnPostLogin()
    {
        return Challenge(new AuthenticationProperties { RedirectUri = &quot;/&quot; }, &quot;IdentityServerOidc&quot;);
    }
}
</code></pre>
<p>最後要確認將 WebClient 的 Port 改成 <code>5002</code>。</p>
<p>完成後先運行 IdentityServer 專案之後運行 WebClient，瀏覽器顯示 <code>Index.cshtml</code> 內容，
點擊登入後轉跳到 IdentityServer <code>https://localhost:5001/</code> 要求我們進行登入(帳號:alice/密碼:alice)，
由於我們有開啟 <code>RequireConsent</code>，因此需要在 <code>User profile</code> 選項打勾，允許這個資料被外部讀取，
完成登入之後會馬上轉跳回 WebClient 並且列出會員所有的 Claim。</p>
<p>我們登入成功會在瀏覽器紀錄一個 cookie <code>.AspNetCore.Identity.Application</code>，要注意這個 cookie 是頒發給
WebClient 使用的，因此直接到 F12 清除掉此 cookie 只會將 WebClient 登出，並不影響 IdentityServer 的登入狀態，
所以你會發現清除後刷新頁面會再次連線到 IdentityServer 並取得新的 Token。</p>
<p>成功登入後我們還需要登出頁面，
注意需要將 WebClient 的 cookie 還要清除遠端服務器的 cookie 最後在轉跳回原頁面。</p>
<pre><code class="language-text">dotnet new page -n Signout
</code></pre>
<pre><code class="language-text">using Microsoft.AspNetCore.Authentication;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.RazorPages;

namespace WebClient.Pages
{
    public class SignoutModel : PageModel
    {
        public IActionResult OnGet()
        {
            return SignOut(
                new AuthenticationProperties
                {
                    RedirectUri = &quot;/&quot;
                },
                new[] { IdentityConstants.ApplicationScheme, &quot;IdentityServerOidc&quot; });
        }
    }
}
</code></pre>
<p>最後到 <code>_Layout.cshtml</code> 在 navbar 新增登出按鈕</p>
<pre><code class="language-text">&lt;li class=&quot;nav-item&quot;&gt;
    &lt;a class=&quot;nav-link text-dark&quot; asp-area=&quot;&quot; asp-page=&quot;/Signout&quot;&gt;Signout&lt;/a&gt;
&lt;/li&gt;
</code></pre>
<hr />
<h2 id="summary">Summary</h2>
<p>今天學習了如何讓前端頁面使用 IdentityServer 進行登入，有了這套模式後就不用每個 APP 都建立自己的
登入登出邏輯了，任何前端只要安裝 OIDC 函式庫就能共用 IdentityServer 裡面的會員資料非常方便。</p>


          

        </div>
      </div>
  <div id="comments-container" class="row">
    <div id="giscus-container"></div>

<script>
  let giscusLoaded = false;
  function loadGiscus() {
    if (giscusLoaded) return;
    giscusLoaded = true;

    let datarepo = 'allengaodev/allengaodev.github.io'
    let datarepoid='R_kgDOI6sF8g'
    let datacategoryid='DIC_kwDOI6sF8s4CUbuw'
    const script = document.createElement("script");
    script.src = "https://giscus.app/client.js";
    script.setAttribute('data-repo', datarepo);
    script.setAttribute('data-repo-id', datarepoid);
    script.setAttribute('data-category-id', datacategoryid);
    script.setAttribute("data-mapping", "pathname");
    script.setAttribute("data-strict", "0");
    script.setAttribute("data-reactions-enabled", "1");
    script.setAttribute("data-emit-metadata", "0");
    script.setAttribute("data-input-position", "top");
    script.setAttribute("data-theme", "light");
    script.setAttribute("data-lang", "en");
    script.async = true;
    document.getElementById("giscus-container").appendChild(script);
  }

  // 檢查是否滾動到最底部
  function checkScrollBottom() {
    if ((window.innerHeight + window.scrollY) >= document.body.offsetHeight / 2) {
      loadGiscus();
      window.removeEventListener("scroll", checkScrollBottom);
    }
  }

  // 等待滾動結束
  setTimeout(() => {
    checkScrollBottom();
    window.addEventListener("scroll", checkScrollBottom);
  }, 500); // 0.5秒後檢查
</script>

  </div>
    </div>
  </main>

  <hr>

  <!-- Footer -->
  <footer>
  <div class="container">
    <div class="row">
      <div class="col-md-12 text-center">
        <p class="copyright">&#xA9; 2026 by Allen Gao</p>

      </div>
    </div>
  </div>
</footer>


  <!-- Scripts -->
  <script defer src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/js/bootstrap.min.js"></script>
  <script async src="https://cdn.jsdelivr.net/npm/quicklink@2.3.0/dist/quicklink.umd.js"></script>
  <script defer src='/vendor/startbootstrap-clean-blog/js/scripts.min.js'></script>
  

  
</body>

</html>
